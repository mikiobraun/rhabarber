// okay, this is the recap of the original domain concept
//
// each has an optional domain slot which indicates which domain
// it belongs to.
//
// When a function is called which has a domain slot, the
// arguments are converted to that domain if not possible.
//
// This is done in a generic fashion by calling
// object.convertto(domain) which in turn will use the constructors
// domain.new<type> to do all the conversion.
//
// NOTE: domains and types should be orthogonal concepts. That is,
// a list can be a list implemented in rhabarber, python, ruby, 
// or whatever.
//    This is important such that you can find the right function
// without having to convert arguments all the time!

if (true || !defined(DOMAINS_RHA)) {
  DOMAINS_RHA = true;

  rhabarber = new();
  rhabarber.domain = new();
  rhabarber.domain.newint(int:i) = i;
  rhabarber.domain.newreal(real:r) = r;
  rhabarber.domain.string() = "<rhabarber domain>";
  
  int.proto.convert(domain) = domain.newint(this.getint());
  int.proto.getint = fn () this;
  int.proto.domain = rhabarber.domain;
  real.proto.convert(domain) = domain.newreal(this.getreal());
  real.proto.getreal = fn() this;
  real.proto.domain = rhabarber.domain;

  // align arguments with the domain of the function
  convert_call = fn(t) {
    fctdomain = t.get(0).domain;
    for(i in 0:t.len()) {
      v = t.get(i);
      if (v.domain != fctdomain)
        t.set(i, v.convert(py.domain));
    }
    t;
  }
};

