// (1) first pull some of the functions to the global scope

// the only stuff that exists in 'root' is:

// (1.1) right now we can't even do assignments like 'x=1'
modules.object.assign(root, \assign, modules.object.assign);

// (1.2) let's get more stuff from the object module
new    = modules.object.new;
ls     = modules.object.ls;
new    = modules.object.new;
has    = modules.object.has;
lookup = modules.object.lookup;
clone  = modules.object.clone;
addr   = modules.object.addr;
ptype  = modules.object.ptypename;
run    = modules.core.run_fn;

// functions for prules
if_fn      = modules.core.if_fn;
fn_fn      = modules.core.fn_fn;
for_fn     = modules.core.for_fn;
while_fn   = modules.core.while_fn;
try_fn     = modules.core.try_fn;
//colon_fn   = modules.core.colon_fn;
literal    = modules.core.literal;
return_fn  = modules.core.return_fn;
deliver_fn = modules.core.deliver_fn;
break_fn   = modules.core.break_fn;
print      = modules.object.print_fn;

// temporarily for testing purposes (as long as we have to overloaded)
inc             = modules.object.inc;
dec             = modules.object.dec;
inc_copy        = modules.object.inc_copy;
dec_copy        = modules.object.dec_copy;
plus_fn         = modules.object.plus_fn;
neg_fn          = modules.object.neg_fn;
minus_fn        = modules.object.minus_fn;
times_fn        = modules.object.times_fn;
divide_fn       = modules.object.divide_fn;
equalequal_fn   = modules.object.equalequal_fn;
notequal_fn     = modules.object.notequal_fn;
less_fn         = modules.object.less_fn;
lessequal_fn    = modules.object.lessequal_fn;
greater_fn      = modules.object.greater_fn;
greaterequal_fn = modules.object.greaterequal_fn;
and_fn          = modules.core.and_fn;
or_fn           = modules.core.or_fn;

not             = modules.bool_fn.bool_not;

// proxy stuff
proxy = fn (s) root.modules.core.proxy_fn(this, s);

// other stuff
load = fn(filename) run(this, filename);
defined = fn(symbolname) has(this, symbolname);

load("testing.rha");
load("list.rha");
load("tuple.rha");
load("tuple.rha");

// symbol stuff
// usually we can create symbol with quote, e.g. '\x', however
// operators can only be created by 'symbol("+")'
symbol.scope = local;
symbol.argnames = tuple(1);
symbol.argnames.set(0, \name);
symbol.fnbody = \modules.symbol_fn.symbol_new(name);

// 'in' element test
in_fn = fn (a, b) {
  // checks whether a is in b
  for (x in b)
    if (a==x) return true;
  return false;
};

// colon

//colon_fn = fn (a, b) {
//  return b;
//
//  check = lookup(a, \check);
//  if (check != void) {
//    // perform type check
//    return check(b);
//  };
//  if (int.check(a) && int.check(b)) {
//    if (a > b) return tuple(0);
//    t = tuple(b-a);
//    k = a;
//    while (k < b) t.set(k-a, k);
//    return t;
//  }
//}

// what is an integer?
//int.check = fn (x) return ptype(x)=="int";

// what is a prule?
//prule.check = fn (x) {
//     if (!has(x, \callable)) return false;
//     if (!has(x, \priority)) return false;
//     return true;
//   }

// what is a function?
// note that builtin functions should also have their stuff available
// in \callable!
//   fn.check = fn (x) {
//     if (!has(x, \callable)) return false;
//     return true;
//   }

// what is a macro?
//   macro.check = fn (x) {
//     if (!fn.check(x)) return false;
//     if (!has(x, \ismacro)) return false;
//     return true;
//   }

// what is iterable?
//   iterable.check = fn (x) {
//     if (!has(x, \iterable)) return false;
//     i = x.iterable;
//     if (!has(i, \begin)) return false;
//     if (!has(i, \done)) return false;
//     if (!has(i, \next)) return false;
//     if (!has(i, \get)) return false;
//     return true;
//   }

// what is an exception?
// any object can be an exception, however if it has the slot 'msg' it
// will be shown
