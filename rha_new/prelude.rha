// (1) first pull some of the functions to the global scope

// the only stuff that exists in 'root' is:

// (1.1) right now we can't even do assignments like 'x=1'
modules.object.assign(root, \assign, modules.object.assign);

// (1.2) let's get more stuff from the object module
new    = modules.object.new;
extend = modules.object.extend;
create_fn_data = modules.core.create_fn_data;
ls     = modules.object.ls;
new    = modules.object.new;
has    = modules.object.has;
lookup = modules.object.lookup;
clone  = modules.object.clone;
addr   = modules.object.addr;
ptype  = modules.object.ptypename;
run    = modules.core.run_fn;

// functions for prules
if_fn      = modules.core.if_fn;
fn_fn      = modules.core.fn_fn;
macro_fn   = modules.core.macro_fn;
for_fn     = modules.core.for_fn;
while_fn   = modules.core.while_fn;
try_fn     = modules.core.try_fn;
colon_fn   = modules.core.colon_fn;
literal    = modules.core.literal;
return_fn  = modules.core.return_fn;
deliver_fn = modules.core.deliver_fn;
break_fn   = modules.core.break_fn;
throw_fn   = modules.core.throw_fn;
print      = modules.object.print_fn;

// temporarily for testing purposes (as long as we have to overloaded)
inc             = modules.object.inc;
dec             = modules.object.dec;
inc_copy        = modules.object.inc_copy;
dec_copy        = modules.object.dec_copy;
plus_fn         = modules.object.plus_fn;
neg_fn          = modules.object.neg_fn;
minus_fn        = modules.object.minus_fn;
times_fn        = modules.object.times_fn;
divide_fn       = modules.object.divide_fn;
equalequal_fn   = modules.object.equalequal_fn;
notequal_fn     = modules.object.notequal_fn;
less_fn         = modules.object.less_fn;
lessequal_fn    = modules.object.lessequal_fn;
greater_fn      = modules.object.greater_fn;
greaterequal_fn = modules.object.greaterequal_fn;
not_fn          = modules.bool_fn.not_fn;
and_fn          = modules.bool_fn.and_fn;
or_fn           = modules.bool_fn.or_fn;


// proxy stuff
proxy = fn (s) root.modules.core.proxy_fn(this, s);

// other stuff
load = fn(filename) run(this, filename);
defined = macro (symbolname) has(local, \symbolname);
undefined = macro( symbolname) has(local, symbolname);

load("testing.rha");
load("tuple.rha");
load("tuple.rha");
load("list.rha");

// symbol stuff
// usually we can create symbol with quote, e.g. '\x', however
// operators can only be created by 'symbol("+")'
symbol.fn_data = create_fn_data(local,
                                tuple(1).set(0,\name),
				\modules.symbol_fn.symbol_new(name));

// 'in' element test
in_fn = fn (a, b) {
  // checks whether a is in b
  for (x in b)
    if (a==x) return true;
  return false;
};


// TYPES:

// in rha_init.c:
//    type = new(); 
//    type.proto = type; // 'type' is its own prototype! 
//    type.name = "type";
type.check = fn (x) { 
  // a simple type check: 
  // * look for this.proto along the parents of 'x'
  // * could be much more sophistacted if we went 
  // also along the type hierarchy 
  while (x != this.proto) { 
    if (!has(x, \parent)) return false; 
    x = x.parent; 
  }
  return true; 
}

//// what is an integer?
//int.check = fn (x) return ptype(x)=="int";

// how to inherit types
subtype = fn (t) {
  if (!type.check(t))
    throw "can't subtype non-types";
  new_t = clone(t);
  new_t.proto = clone(t.proto);
  return new_t;
}


// what is iterable?
iterable = new();
iterable.check = fn (x) {
  if (!has(x, \iter)) return false;
  i = x.iter();
  if (!has(i, \done)) return false;
  if (!has(i, \next)) return false;
  if (!has(i, \get)) return false;
  return true;
}

// colon

colon_fn = fn (a, b) {
  if (type.check(a))
    // perform type check
    return a.check(b);
  print("hallo");
  if (int.check(a) && int.check(b)) {
    if (a > b) return tuple(0);
    t = tuple(b-a);
    k = a;
    while (k < b) t.set(k-a, k);
    return t;
  }
  throw "either 0:5 or int:x";
}


