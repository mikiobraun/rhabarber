// (1) first pull some of the functions to the global scope

// the only stuff that exists in 'root' is:

// (1.1) right now we can't even do assignments like 'x=1'
modules.object.assign(root, \assign, modules.object.assign);

// (1.2) let's get more stuff from the object module
new    = modules.object.new;
extend = modules.object.extend;
create_fn_data = modules.core.create_fn_data;
ls     = modules.object.ls;
new    = modules.object.new;
has    = modules.object.has;
lookup = modules.object.lookup;
clone  = modules.object.clone;
addr   = modules.object.addr;
run    = modules.core.run_fn;

// functions for prules
if_fn      = modules.core.if_fn;
fn_fn      = modules.core.fn_fn;
macro_fn   = modules.core.macro_fn;
for_fn     = modules.core.for_fn;
while_fn   = modules.core.while_fn;
try_fn     = modules.core.try_fn;
//colon_fn   = modules.core.colon_fn;  // now implemented below
literal    = modules.core.literal;
return_fn  = modules.core.return_fn;
deliver_fn = modules.core.deliver_fn;
break_fn   = modules.core.break_fn;
throw_fn   = modules.core.throw_fn;
print      = modules.object.print_fn;

// temporarily for testing purposes (as long as we have to overloaded)
inc             = modules.object.inc;
dec             = modules.object.dec;
inc_copy        = modules.object.inc_copy;
dec_copy        = modules.object.dec_copy;
plus_fn         = modules.object.plus_fn;
neg_fn          = modules.object.neg_fn;
minus_fn        = modules.object.minus_fn;
times_fn        = modules.object.times_fn;
divide_fn       = modules.object.divide_fn;
equalequal_fn   = modules.object.equalequal_fn;
notequal_fn     = modules.object.notequal_fn;
less_fn         = modules.object.less_fn;
lessequal_fn    = modules.object.lessequal_fn;
greater_fn      = modules.object.greater_fn;
greaterequal_fn = modules.object.greaterequal_fn;
not_fn          = modules.bool_fn.not_fn;
and_fn          = modules.bool_fn.and_fn;
or_fn           = modules.bool_fn.or_fn;


// proxy stuff
proxy = fn (s) root.modules.core.proxy_fn(this, s);

// other stuff
load = fn(filename) run(this, filename);
defined = macro (symbolname) has(local, \symbolname);
undefined = macro( symbolname) has(local, symbolname);

load("testing.rha");
load("tuple.rha");
load("tuple.rha");
load("list.rha");

// symbol stuff
// usually we can create symbol with quote, e.g. '\x', however
// operators can only be created by 'symbol("+")'
symbol.fn_data = create_fn_data(local,
                                tuple(1).set(0,\name),
				\modules.symbol_fn.symbol_new(name));

// 'in' element test
in_fn = fn (a, b) {
  // checks whether a is in b
  for (x in b)
    if (a==x) return true;
  return false;
};


// typing stuff

// type    = new();        // in rha_init.c
type.name  = "type";
type.type  = type;         // 'type' is of type 'type'
type.proto = type;         // 'type' is its own prototype
type.check = fn (x) { 
  while (x != this.proto) {
    if (!has(x, \parent)) return false; 
    x = x.parent; 
  }
  return true;
}
type(x) = x.type.name;     // try 'type(17)'

// ptype   = clone(type);  // in rha_init.c
ptype.name  = "ptype";
ptype.proto = ptype;
ptype.check = fn (x) ptype(x)==ptype(this.proto);

// comments:
// (i)   'int', 'real' are examples of ptypes
// (ii)  'shape', 'circle' are examples of types
// (iii) 'type', 'ptype' are examples of type-types.
//       note that prototypes of type-types are the 
//       types themselves.
// (iv)  'iterable', 'callable' are examples of types without
//       prototype slot, since they measure properties.  In Java they
//       are called "interfaces".  We can't
//       instantiate from types with prototype slot.

// how to instantiate a type
instance = fn (t) return clone(t.proto);

// how to inherit types/interfaces
subtype = fn (t) {
  new_t = clone(t);
  if (has(t, \proto))
    new_t.proto = clone(t.proto);
  return new_t;
}

// what is iterable?
iterable = clone(type);  // use 'clone' instead of 'subtype' for interfaces
iterable.check = fn (x) {
  if (!has(x, \iter)) return false;
  i = x.iter();
  if (!has(i, \done)) return false;
  if (!has(i, \next)) return false;
  if (!has(i, \get)) return false;
  return true;
}

// colon
colon_fn = fn (a, b) {
  // is 'a' a type?
  if (type.check(a))
    // yes, perform type check
    return a.check(b);
  // otherwise generate a tuple
  if (int.check(a) && int.check(b)) {
    if (a > b) return tuple(0);
    t = tuple(b-a);
    k = a;
    while (k < b) {
      t.set(k-a, k);
      k += 1;  // note that k++ is wrong since it changes 'a'
    }
    return t;
  }
  throw "either 0:5 or int:x";
}


