// (1) first pull some of the functions to the global scope

// the only stuff that exists in 'root' is:

// (1.1) right now we can't even do assignments like 'x=1'
modules.object.assign(root, \assign, modules.object.assign);

// (1.2) let's get more stuff from the object module
new      = modules.object.new;
extend   = modules.object.extend;
ls       = modules.object.ls;
new      = modules.object.new;
has      = modules.object.has;
lookup   = modules.object.lookup;
lookup_local = modules.object.lookup_local;
location = modules.object.location;
clone    = modules.object.clone;
addr     = modules.object.addr;
run      = modules.core.run_fn;

// functions for prules
if_fn      = modules.core.if_fn;
fn_fn      = modules.core.fn_fn;
macro_fn   = modules.core.macro_fn;
for_fn     = modules.core.for_fn;
while_fn   = modules.core.while_fn;
try_fn     = modules.core.try_fn;
//colon_fn   = modules.core.colon_fn;  // now implemented below
literal    = modules.core.literal;
return_fn  = modules.core.return_fn;
deliver_fn = modules.core.deliver_fn;
break_fn   = modules.core.break_fn;
throw_fn   = modules.core.throw_fn;
print      = modules.object.print_fn;

not_fn          = modules.bool_fn.not_fn;
and_fn          = modules.bool_fn.and_fn;
or_fn           = modules.bool_fn.or_fn;


// proxy stuff
proxy = fn (s) root.modules.core.proxy_fn(this, s);

// other stuff
load = fn(filename) run(this, filename);
defined = macro (symbolname) has(local, \symbolname);
undefined = macro( symbolname) has(local, symbolname);

load("testing.rha");
load("tuple.rha");
load("tuple.rha");
load("list.rha");

// symbol stuff
// usually we can create symbol with quote, e.g. '\x', however
// operators can only be created by 'symbol("+")'
symbol(name) = modules.symbol_fn.symbol_new(name);

// 'in' element test
in_fn = fn (a, b) {
  // checks whether a is in b
  for (x in b)
    if (a==x) return true;
  return false;
};


// typing stuff

// type    = new();        // in rha_init.c (used by 'ptype')
type.name  = "type";
type.to_string = fn () this.name;
type.type  = type;         // 'type' is of type 'type'
type.proto = type;         // 'type' is its own prototype
type.check = fn (x) { 
  while (x != this.proto) {
    if (!has(x, \parent)) return false; 
    x = x.parent; 
  }
  return true;
}
typename(x) = x.type.name;     // try 'type(17)'
	    // note that 'type(x) = x.type.name' is not a good idea,
	    // since then also 'bool(17)' will do '17.type.name'
	    // instead of casting.

// ptype   = clone(type);  // in rha_init.c (used by automatically
                           // generated types for primitive types)
ptype.name  = "ptype";
ptype.proto = ptype;
ptype.check = fn (x) "object" != typename(x) == typename(this.proto);

// comments:
// (i)   'int', 'real' are examples of ptypes
// (ii)  'shape', 'circle' are examples of types
// (iii) 'type', 'ptype' are examples of type-types.
//       note that prototypes of type-types are the 
//       types themselves.
// (iv)  'iterable', 'callable' are examples of types without a
//       prototype slot, since they measure properties.  In Java they
//       are called "interfaces".  We can't
//       instantiate from types without a prototype slot.

// how to instantiate a type
instance = fn (t) clone(t.proto);

// how to subtype
// note that subtypes of a type 't' can appear everywhere where 't'
// can appear.  the usual way to subtype is by 'clone', however this
// doesn't work for types, but only non-types.
subtype = fn (t) {
  new_t = clone(t);
  if (has(t, \proto))
    new_t.proto = clone(t.proto);
  return new_t;
}

// is 'x' an instance of a subtype of 't'?
isa = fn (x, t) {
  // 'location' allows us to jump to the relevant objects in the
  // parent path
  while (true) {
    x = location(x, \type);
    if (x.type == t) return true;
    if (!has(x, \parent)) return false;
    x = x.parent;
  }
}

// colon can be used for typechecks and to generate tuple
colon_fn = fn (a, b) {
  // is 'a' a type?
  if (type.check(a))
    // yes, perform type check
    return a.check(b);
  // otherwise generate a tuple
  // later on, this should be a true generator using 'yield'
  if (int.check(a) && int.check(b)) {
    if (a > b) return tuple(0);
    t = tuple(b-a);
    k = a;
    while (k < b) {
      t.set(k-a, k);
      k += 1;  // note that k++ is wrong since it changes 'a'
    }
    return t;
  }
  throw "either 0:5 or int:x";
}


// casting
int(x) = modules.int_fn.int_cast(x);  // try 'int(3.14)'

