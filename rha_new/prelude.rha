// (1) first pull some of the functions to the global scope

// the only stuff that exists in 'root' is:

// (1.1) work done by rha_init() in rha_init.c
//
//   type = new();
//   type.proto = type;
//   type.check = fn (x) modules.object.check(this, x);
//
//   bool.check = fn (x) modules.object.pcheck(this, x);
//   int.check = fn (x) modules.object.pcheck(this, x);
//   ...
//
//   pattern = clone(type);
//   pattern.proto = new();
//   pattern(type:t, symbol:s) = {
//     p = new(pattern);
//     p.patterntype = t;
//     p.patternliteral = s;
//     return p;
//   }
//
//   assign_fn = modules.object.assign_fn;
//   extend = modules.object.extend;

// (1.2) more essential stuff
print      = modules.object.print_fn;
new      = modules.object.new;
// let's overloaded that builtin function!!!
new(type:t) = {
  x = new(); // creates new object
  x.parent = t.proto;
  return x;
}

// note that if 't' doesn't have a slot 'proto' this code raises an 
// look-up-failed exception, which is the intended behavior. 
// to get an empty object with a certain parent pointer 
// use 'clone'
eval(x)  = eval(this, x);
assign_many = modules.object.assign_many;
clone    = modules.object.clone;
rm       = modules.object.rm;
ls       = modules.object.ls;
new      = modules.object.new;
has      = modules.object.has;
lookup   = modules.object.lookup;
	 lookup_local = modules.object.lookup_local;
	 location = modules.object.location;
clone    = modules.object.clone;
addr     = modules.object.addr;
run      = modules.core.run_fn;
error    = modules.messages.error;
warning  = modules.messages.warning;
resolve  = modules.parse.resolve;
is_void  = modules.object.is_void;

// take care of 'syntactic functions', which generate no frame to return from
fn_data(f) = modules.list_fn.list_first(f.fn_data);
no_frame(f) = { fd = fn_data(f); fd.no_frame = true; f };

// (1.3) functions that are accessed after applying prules
if_fn      = no_frame(modules.core.if_fn); 
fn_fn      = modules.core.fn_fn;
macro_fn   = modules.core.macro_fn;
for_fn     = no_frame(modules.core.for_fn); 
while_fn   = no_frame(modules.core.while_fn);
try_fn     = modules.core.try_fn; 
return_fn  = no_frame(modules.core.return_fn);
deliver_fn = no_frame(modules.core.deliver_fn);
break_fn   = no_frame(modules.core.break_fn); 
throw_fn   = no_frame(modules.core.throw_fn);

// (1.4) proxy and other useful stuff
proxy = fn (s) root.modules.core.proxy_fn(this, s);
run(filename) = run(root, filename);
defined = macro (symbolname) has(local, \symbolname);
undefined = macro (symbolname) !has(local, \symbolname);
//assert = macro (cond) if (!cond) throw to_string(cond) + " FAILED";

// (1.5) macros for writing tests (see test.rha for an example)
test = macro (x) {
  failure = 0;
  success = 0;
  name = x;
}
check = macro (x) {
  if (eval(local, x))
    success++;
  else {
    print("FAILED: " ,\x);
    failure++;
  }
}
summarize = macro () {
  s = "[test] " + string(success) + "/" + string(failure+success);
  if (failure > 0)
    s += " \tSOME FAILED in " + name;
  else
    s += " \tALL PASSED in " + name;
  print(s);
}
runtest = fn () run(root, "test.rha");


// typing stuff

// type    = new();        // in rha_init.c (used by 'ptype')
// type.proto = type;
// type.check = fn (x) modules.object.check(this, x)
type.name  = "type";
type.string = fn () this.name;
type.type  = type;         // 'type' is of type 'type'
typename = fn (x) x.type.name;     // try 'typename(17)'
	    // note that 'type(x) = x.type.name' is not a good idea,
	    // since then also 'bool(17)' will do '17.type.name'
	    // instead of casting.

// comments:
// (i)   'int', 'real' are examples of types with prototypes
// (ii)  'type', 'ptype' are examples of type-types.
//       note that prototypes of type-types are the 
//       types themselves.
// (iii) 'iterable', 'callable' are examples of types without a
//       prototype slot, since they measure properties.  They are
//       merely like guards in Haskell.
// (iv)  'comparable' does have a prototype slot, but instantiating
//       it, does note create something useful since the
//       implementation of 'cmp' is missing.

// how to subtype
// note that subtypes of a type 't' can appear everywhere where 't'
// can appear.  the usual way to subtype is by 'clone', however this
// doesn't work for types, but only non-types.
subtype = fn (type:t) {
  st = clone(t);
  if (has(t, \proto))
    st.proto = clone(t.proto);
  return st;
}

// is 'x' an instance of a subtype of 't'?
isa = fn (x, t) {
  // 'location' allows us to jump to the relevant objects in the
  // parent path
  while (true) {
    x = location(x, \type);
    if (x.type == t) return true;
    if (!has(x, \parent)) return false;
    x = x.parent;
  }
}

// what is iterable?
iterable = new(type);
iterable.check = fn (x) {
  if (!has(x, \iter)) return false;
  i = x.iter();
  if (!has(i, \done)) return false;
  if (!has(i, \next)) return false;
  if (!has(i, \get)) return false;
  return true;
}


// lazy 'and' and 'or'
and_fn = macro (x, y) if (!eval(local, x)) false
                      else if (!eval(local, y)) false
                      else true;
//and_fn = fn (bool:x, bool:y) modules.bool_fn.bool_and(x, y);
or_fn = macro(x, y) if (eval(local, x)) true
                    else if (eval(local, y)) true
                    else false;
//or_fn  = fn (bool:x, bool:y) modules.bool_fn.bool_or(x, y);

// colon can be used for typechecks and for slices
colon_fn (a, b, c) = {
  // is 'a' a type?
  if (type.check(a)) // note that we can't use here 'type:a'
    // yes, perform type check and ignore 'b'
    return a.check(c);
  // otherwise generate a slice
  return slice(a, b, c);
}
colon_fn(a, b) = slice(a, b);

// == and != are special
// the problem with overloading here is that type checking might use
// certain function which are overloaded themselves, which needs to be
// resolved with type checking and so on...

equalequal_fn = modules.object.equalequal_fn;
notequal_fn   = modules.object.notequal_fn;

// complex literal
literal = fn (env, list:pl) {
  m = 0;
  try {
    m = mat.literal(env, pl);
  }
  catch (e) {
    m = list.literal(env, pl);
  }
  if (m == 0)
    error("(literal) can't parse complex literal");
  return m;
}
split_parselist = fn (list:symlist, env, list:pl) {
  if (symlist.len() == 0)
    return eval(env, resolve(env, pl));
  // else we need to split by the next symbol
  split = symlist.shift();
  sink = list();
  part = list();
  for (x in pl) {
    if (x == split) {
      if (part.len()==0)
	error("(literal) too many "+string(split));
      // split here
      sink.push(split_parselist(symlist, env, part));
      part = list();
    }
    else
      part.push(x);
  }
  if (part.len()==0)
    error("(literal) too many "+string(split));
  sink.push(split_parselist(symlist, env, part));
  symlist.unshift(split);
  return sink;
}


// temporarily for testing purposes
inc             = modules.object.inc;
dec             = modules.object.dec;
inc_copy        = modules.object.inc_copy;
dec_copy        = modules.object.dec_copy;
to_string       = modules.object.to_string;

// fn_data_proto
// note that there is no 'fn_data' in root, since otherwise 'root'
// would be callable.  thus we only have 'fn_data_proto' which allows
// us to get a pretty 'fn_data' view and other stuff
fn_data_proto.parent = list.proto;   // basically, fn_data is a
                                     // subtype of 'list'
fn_data_proto.string = fn () {
  if (fn_data_proto == this)
    return "<fn_data prototype>";
  s = "";
  i = 0;
  for (x in this) {
    if (i > 0) s += "\n";
    s += string(i++) + " ";
    s += string(x);
  }
  return s;
}

// implemention_proto
implementation_proto.string = fn () {
  s = "";
  if (builtin:this.fnbody)
    s += "builtin(";
  else
    s += "function(";
  j = 0;
  if (has(this, \signature)) {
    for (y in this.signature) {
      arg = string(y);
      if (arg.len()>=3 && arg((-3):(0))=="arg")
	  arg += string(j);
      if (j++ > 0) s += ", ";
      s += arg;
    }
  }
  if (has(this, \varargs) && lookup(this, \varargs))
    if (j == 0)
      s += "...";
    else
      s += ", ...";
  return s + ")";
}


// any
any = new(type);
any.check = fn (x) true;

// symbol
symbol.proto.string = fn () modules.symbol_fn.symbol_to_string(this);
symbol(name) = modules.symbol_fn.symbol_new(name);
equalequal_fn(symbol:x, symbol:y) = modules.symbol_fn.symbol_equalequal(x, y);

// pattern
pattern.proto.string = fn () {
  s = "";
  if (has(this, \patterntype))
    s += string(this.patterntype) + ":";
  if (has(this, \patternliteral))
    s += string(this.patternliteral);
  else
    s += "arg";
  return s;
}

// types
less_fn(type:x, type:y) = x:y;
or_fn(type:t1, type:t2) = {
  t = new(type);
  t.check = fn (x) t1:x || t2:x;
  return t;
}
plus_fn(type:t1, type:t2) = {
  // (t1+t2):x  == t1:x && t2:x
  t = new(type);
  t.check = fn (x) t1:x && t2:x;
  return t;
}
times_fn(type:t1, type:t2) = { 
  // int*real*string   (tuples of types)
  t = new(type); 
  t.check = fn (x) tuple.check(x) 
                   && x.len() == 2 
                   && t1:x(0) && t2:x(1); 
  return t;
}


// builtins
builtin.proto.string = fn () modules.object.builtin_to_string(this);


// addresses
address.proto.string = fn () modules.object.address_to_string(this);


//----------------------------------------------------------------------
// slices
slice = new(type);
slice(int:begin, int:step) = {
  s = new(slice);
  s.begin = begin;
  if (step == 0)
    error("step size must be positive or negative but not zero");
  s.step = step;
  return s;
}
slice(int:begin, int:step, int:end) = {
  s = slice(begin, step);
  s.end = end;
  return s;
}
slice.proto = new();
slice.proto.string = fn () {
  s = this.begin.string() + ":" + this.step.string() + ":";
  if (has(this, \end))
    s += this.end.string();
  return s;
}
slice.proto.iter = fn () {
  // 'this' slice must have an upper bound
  if (this.step > 0) {
    // for positive steps an upper bound is required
    if (!has(this, \end))
      error("positive steps require upper bound to convert to list");
    end = this.end;
    sign = 1;
  }
  else {
    if (has(this, \end))
      end = this.end;
    else
      end = -1; // default for negative step size
    sign = -1;
  }
  i = new();
  i.counter = this.begin;
  i.step    = this.step;
  i.bound   = end;
  i.done = fn () sign*this.counter >= sign*this.bound;
  i.next = fn () this.counter += this.step;
  i.get = fn () this.counter;
  return i;
}
idx = fn (i, len) {
  // convert negative indices to count from the end
  if (i >= len || -i > len)
    error("index out of bounds");
  if (i < 0) i = len + i;
  return i;
}


// bools
bool.proto.string      = fn () modules.bool_fn.bool_to_string(this);
not_fn(bool:x)         = modules.bool_fn.bool_not(x);
//equalequal_fn(bool:x, bool:y) = modules.bool_fn.bool_equalequal(x, y);

// strings
string.proto.string         = fn () modules.string_fn.string_to_string(this);
string()                    = "<somescope>";
string(x)                   = modules.object.to_string(x);
plus_fn(string:x, string:y) = modules.string_fn.string_concat(x, y);
string.proto.len = fn () modules.string_fn.string_len(this);
string.proto.get = fn (int:i) modules.string_fn.string_get(this, i);
string.proto.set = fn (int:i, string:v) modules.string_fn.string_set(this, i, v);
string.proto(int:i) = static.get(i);
// slices, e.g. s(1:3)
string.proto(slice:s) = static(list(s, static.len()));
// list of indices, e.g. s([1,3,6])
string.proto(list:idx) = {
  s = "";
  for (i in idx)
    s += static.get(i);
  return s;
}
//equalequal_fn(string:x, string:y) = modules.string_fn.string_equalequal(x, y);

//----------------------------------------------------------------------
// natural numbers (not yet working as indented...)
nat = subtype(int);
nat.name = "nat";
nat.check = fn (x) int:x && x >= 0;


//----------------------------------------------------------------------
// integers
int.proto.string              = fn () modules.int_fn.int_to_string(this);
apostrophe_fn(int:x) = x;
plus_fn(int:x, int:y)         = modules.int_fn.int_plus(x, y);
neg_fn(int:x)                 = modules.int_fn.int_neg(x);
minus_fn(int:x, int:y)        = modules.int_fn.int_minus(x, y);
times_fn(int:x, int:y)        = modules.int_fn.int_times(x, y);
divide_fn(int:x, int:y)       = modules.int_fn.int_divide(x, y);
less_fn(int:x, int:y)         = modules.int_fn.int_less(x, y);
lessequal_fn(int:x, int:y)    = modules.int_fn.int_lessequal(x, y);
greater_fn(int:x, int:y)      = modules.int_fn.int_greater(x, y);
greaterequal_fn(int:x, int:y) = modules.int_fn.int_greaterequal(x, y);
int(real:x)                   = modules.int_fn.int_cast(x);  
exp(int:x) = modules.real_fn.real_exp(real(x));
sin(int:x) = modules.real_fn.real_sin(real(x));
cos(int:x) = modules.real_fn.real_cos(real(x));
//equalequal_fn(int:x, int:y) = modules.int_fn.int_equalequal(x, y);

//----------------------------------------------------------------------
// reals
real.proto.string               = fn () {
  s = modules.real_fn.real_to_string(this);
  if (this >= 0)
    s = " " + s;
  return s;
}
apostrophe_fn(real:x) = x;
plus_fn(real:x, real:y)         = modules.real_fn.real_plus(x, y);
plus_fn(int:x, real:y)          = modules.real_fn.real_plus(real(x), y);
plus_fn(real:x, int:y)          = modules.real_fn.real_plus(x, real(y));
neg_fn(real:x)                  = modules.real_fn.real_neg(x);
minus_fn(real:x, real:y)         = modules.real_fn.real_minus(x, y);
minus_fn(int:x, real:y)          = modules.real_fn.real_minus(real(x), y);
minus_fn(real:x, int:y)          = modules.real_fn.real_minus(x, real(y));
times_fn(real:x, real:y)         = modules.real_fn.real_times(x, y);
times_fn(int:x, real:y)          = modules.real_fn.real_times(real(x), y);
times_fn(real:x, int:y)          = modules.real_fn.real_times(x, real(y));
divide_fn(real:x, real:y)         = modules.real_fn.real_divide(x, y);
divide_fn(int:x, real:y)          = modules.real_fn.real_divide(real(x), y);
divide_fn(real:x, int:y)          = modules.real_fn.real_divide(x, real(y));
less_fn(real:x, real:y)         = modules.real_fn.real_less(x, y);
less_fn(int:x, real:y)         = modules.real_fn.real_less(real(x), y);
less_fn(real:x, int:y)         = modules.real_fn.real_less(x, real(y));
lessequal_fn(real:x, real:y)    = modules.real_fn.real_lessequal(x, y);
lessequal_fn(int:x, real:y)    = modules.real_fn.real_lessequal(real(x), y);
lessequal_fn(real:x, int:y)    = modules.real_fn.real_lessequal(x, real(y));
greater_fn(real:x, real:y)      = modules.real_fn.real_greater(x, y);
greater_fn(int:x, real:y)      = modules.real_fn.real_greater(real(x), y);
greater_fn(real:x, int:y)      = modules.real_fn.real_greater(x, real(y));
greaterequal_fn(real:x, real:y) = modules.real_fn.real_greaterequal(x, y);
greaterequal_fn(int:x, real:y) = modules.real_fn.real_greaterequal(real(x), y);
greaterequal_fn(real:x, int:y) = modules.real_fn.real_greaterequal(x, real(y));
real(int:x)                     = modules.real_fn.real_cast(x);  
exp(real:x) = modules.real_fn.real_exp(x);
sin(real:x) = modules.real_fn.real_sin(x);
cos(real:x) = modules.real_fn.real_cos(x);
//equalequal_fn(real:x, real:y) = modules.real_fn.real_equalequal(x, y);
//equalequal_fn(int:x, real:y) = modules.real_fn.real_equalequal(real(x), y);
//equalequal_fn(real:x, int:y) = modules.real_fn.real_equalequal(x, real(y));

max(x, y) = if (x < y) y else x;
min(x, y) = if (y < x) y else x;

//----------------------------------------------------------------------
// matrices
mat.literal = fn (env, list:pl) {
  x = split_parselist(list().push(symbol(";"), symbol(",")), env, pl);
  rows = x.len();
  cols = x(0).len();
  // check that all rows have same size
  for (row in x)
    if (row.len() != cols)
      error("(literal) all rows must have same number of entries");
  // check that all entries are type 'real'
  m = mat(cols, rows);  // we transpose later
  i = 0;
  for (row in x)
    for (a in row) {
      if (!real:a && !int:a) {
	error("(literal) all entries of a matrix must be of type 'real' or 'int'");
      }
      else
	m.setl(i++, real(a));
    }
  return m';
}
linsolve(mat:A, mat:b) = modules.mat_fn.mat_solve(A, b);
rand(int:rows, int:cols) = modules.mat_fn.mat_rand(rows, cols);
randn(int:rows, int:cols) = modules.mat_fn.mat_randn(rows, cols);
apostrophe_fn(mat:x) = modules.mat_fn.mat_transpose(x);
mat.proto.string = fn () modules.mat_fn.mat_to_string(this);
eye(int:n) = modules.mat_fn.mat_eye(n);
mat(int:rows, int:cols) = modules.mat_fn.mat_new(rows, cols);
mat(list:l) = {
  // converts the list into a row vector
  m = mat(1, l.len());
  i = 0;
  for (x in l)
    m(i++) = x;
  return m;
}
mat.proto(int:i) = static.getl(i);
mat.proto(int:i, int:j) = static.get(i, j);
mat.proto.extend = fn (signature, scope, rhs) {
  if (signature.len() == 1) {
    l = signature(0);
    value = eval(scope, rhs);
    this.setl(l, value);
    return value;
  }
  else if (signature.len() == 2) {
    row = signature(0);
    col = signature(1);
    value = real(eval(scope, rhs));
    this.set(row, col, value);
    return value;
  }
  else
    error("(mat) either m(int:l) or m(int:row, int:col)");
}
mat.copy = fn () modules.mat_fn.mat_copy(this);
mat.proto.rows = fn () modules.mat_fn.mat_rows(this);
mat.proto.cols = fn () modules.mat_fn.mat_cols(this);
mat.proto.len  = fn () modules.mat_fn.mat_len(this);
mat.proto.getl = fn (int:i) modules.mat_fn.mat_getl(this, i);
mat.proto.setl = fn (int:i, real:v) modules.mat_fn.mat_setl(this,i, v);
mat.proto.get  = fn (int:i, int:j) modules.mat_fn.mat_get(this, i, j);
mat.proto.set  = fn (int:i, int:j, real:v) modules.mat_fn.mat_set(this, i, j, v);
mat.proto.norm = fn () modules.mat_fn.mat_norm(this);
mat.proto.max  = fn () modules.mat_fn.mat_max(this);
mat.proto.min  = fn () modules.mat_fn.mat_min(this);
mat.proto.scale = fn (real:v) modules.mat_fn.mat_scale(this, v);
mat.proto.repmat = fn (int:i, int:j) modules.mat_fn.mat_repmat(this, i, j);
mat.proto.reshape = fn (int:i, int:j) modules.mat_fn.mat_reshape(this, i, j);
mat.proto.neg  = fn () modules.mat_fn.mat_minus(this);
plus_fn(mat:x, mat:y)  = modules.mat_fn.mat_plus_mat(x, y);
plus_fn(int:x, mat:y)  = modules.mat_fn.real_plus_mat(real(x), y);
plus_fn(mat:x, int:y)  = modules.mat_fn.mat_plus_real(x, real(y));
plus_fn(mat:x, real:y) = modules.mat_fn.mat_plus_real(x, y);
plus_fn(real:x, mat:y) = modules.mat_fn.real_plus_mat(x, y);
minus_fn(mat:x, mat:y)  = modules.mat_fn.mat_minus_mat(x, y);
minus_fn(int:x, mat:y)  = modules.mat_fn.real_minus_mat(real(x), y);
minus_fn(mat:x, int:y)  = modules.mat_fn.mat_minus_real(x, real(y));
minus_fn(mat:x, real:y) = modules.mat_fn.mat_minus_real(x, y);
minus_fn(real:x, mat:y) = modules.mat_fn.real_minus_mat(x, y);
times_fn(mat:x, mat:y)  = modules.mat_fn.mat_times_mat(x, y);
times_fn(int:x, mat:y)  = modules.mat_fn.real_times_mat(real(x), y);
times_fn(mat:x, int:y)  = modules.mat_fn.mat_times_real(x, real(y));
times_fn(mat:x, real:y) = modules.mat_fn.mat_times_real(x, y);
times_fn(real:x, mat:y) = modules.mat_fn.real_times_mat(x, y);
dottimes_fn(mat:x, mat:y)  = modules.mat_fn.mat_dottimes_mat(x, y);
dottimes_fn(int:x, mat:y)  = modules.mat_fn.real_times_mat(real(x), y);
dottimes_fn(mat:x, int:y)  = modules.mat_fn.mat_times_real(x, real(y));
dottimes_fn(mat:x, real:y) = modules.mat_fn.mat_times_real(x, y);
dottimes_fn(real:x, mat:y) = modules.mat_fn.real_times_mat(x, y);
dotdivide_fn(mat:x, mat:y)  = modules.mat_fn.mat_dotdivide_mat(x, y);
dotdivide_fn(mat:x, int:y)  = modules.mat_fn.mat_divide_real(x, real(y));
dotdivide_fn(mat:x, real:y) = modules.mat_fn.mat_divide_real(x, y);
dotdivide_fn(real:x, mat:y) = modules.mat_fn.real_divide_mat(x, y);
exp(mat:x) = modules.mat_fn.mat_exp(x);
sin(mat:x) = modules.mat_fn.mat_sin(x);
sinc(mat:x) = modules.mat_fn.mat_sinc(x);
mat.proto.iter = fn () {
  i = new();
  i.counter = 0;
  i.matrix = this;
  i.done = fn () i.counter == i.matrix.len();
  i.next = fn () this.counter++;
  i.get = fn () this.matrix.getl(this.counter);
  return i;
}




//----------------------------------------------------------------------
// tuples
tuple(int:len) = modules.tuple_fn.tuple_new(len);
tuple(list:l) = modules.list_fn.list_to_tuple(l);
tuple(iterable:l) = tuple(list(l));
plus_fn(tuple:a, tuple:b) = {
  l = list();
  for (x in a)
    l.push(x);
  for (x in b)
    l.push(x);
  return tuple(l);
}
tuple.proto.string = fn () modules.tuple_fn.tuple_to_string(this);
tuple.literal      = fn (env, pl) tuple(list.literal(env, pl));
tuple.proto.len    = fn () modules.tuple_fn.tuple_len(this);
tuple.proto.set    = fn (i, x) modules.tuple_fn.tuple_set(this, i, x);
tuple.proto.get    = fn (i) modules.tuple_fn.tuple_get(this, i);
tuple.proto.shift  = fn () modules.tuple_fn.tuple_shift(this);
tuple.proto.iter = fn () {
  i = new();
  i.counter = 0;
  i.tuple = this;
  i.done = fn () i.counter == i.tuple.len();
  i.next = fn () this.counter++;
  i.get = fn () this.tuple.get(this.counter);
  return i;
}
rm(tuple.proto, \fn_data); // to make sure we get a new implementation
rm(tuple.proto, \extend);  // otherwise we can't overload
// member access, e.g. t(0)
tuple.proto(int:i) = static.get(i); // member access, e.g. t(0)
// slices, e.g. t(1:3)
tuple.proto(slice:s) = static(list(s, static.len()));
// list of indices, e.g. t([1,3,6])
tuple.proto(list:idx) = {
  t = tuple(idx.len());
  j = 0;
  for (i in idx)
    t.set(j++, static.get(i));
  return t;
}
// member replace, e.g. t(0)=17
tuple.proto.extend = fn (signature, scope, rhs) {
  if (signature.len() != 1)
    error("(tuple) invalid tuple index");
  index = signature(0);
  value = eval(scope, rhs);
  if (iterable:index) {
    // then the value is either iterable or considered constant for
    // all entries
    index = list(index, static.len()); // transform neg entries
    if (iterable:value)
      for ([i,v] in zip(index, value))
	this.set(i, v);
    else
      // all entries get the same value
      for (i in index)
	this.set(i, value);
  }
  else
    // we only assign one value
    this.set(index, value);
  // that's it
  return value;
}

//----------------------------------------------------------------------
// lists
list() = modules.list_fn.list_new();
list(tuple:t) = modules.tuple_fn.tuple_to_list(t);
list(iterable:s) = {
  // convert an interable to a list
  l = list();
  for (i in s)
    l.append(i);
  return l;
}
list(slice:s, int:len) = {
  // convert 's' to a list
  // and resolve negative to count from the back of an array of length
  // 'len'
  begin = idx(s.begin, len);
  if (has(s, \end) && s.end != len) {
    // note the 's.end != len' check
    // it is necessary since 'len' is itself not a valid index into an
    // array of size 'len'
    end = idx(s.end, len);
  }
  else
    end = len;
  return list(slice(begin, s.step, end));
}
list.literal(env, list:pl) = split_parselist(list().push(symbol(",")), env, pl);
list.proto.string    = fn () modules.list_fn.list_to_string(this);
list.proto.len       = fn () modules.list_fn.list_len(this);
list.proto.copy      = fn () modules.list_fn.list_copy(this);
list.proto.append    = fn (x) modules.list_fn.list_append(this, x);
list.proto.prepend   = fn (x) modules.list_fn.list_prepend(this, x);
//  note that right now we have a name clash for 'extend' with the one
//  that is lookup for stuff like:    list(17)
//list.proto.extend   = fn (l) modules.list_fn.list_extend(this, l);
plus_fn(list:a, list:b) = modules.list_fn.list_extend(a, b);
list.proto.first    = fn () modules.list_fn.list_first(this);
list.proto.last     = fn () modules.list_fn.list_last(this);
list.proto.pop      = fn () modules.list_fn.list_poplast(this);
list.proto.push     = fn (...) for (x in args) modules.list_fn.list_append(this, x);
list.proto.shift    = fn () modules.list_fn.list_popfirst(this);
list.proto.unshift  = fn (...) for (x in args) modules.list_fn.list_prepend(this, x);
list.proto.to_tuple = fn () modules.list_fn.list_to_tuple(this);
list.proto.iter     = fn () {
  i = modules.list_fn.list_begin(this);
  i.next = fn () modules.list_fn.list_next(this);
  i.done = fn () modules.list_fn.list_done(this);
  i.get  = fn () modules.list_fn.list_get(this);
  return i;
}
rm(list.proto, \fn_data);
list.proto(int:i) = tuple(static)(i);

// zip two iterables to one list
zip = fn (iterable:x, iterable:y) {
  l = list();
  x = list(x);
  for (b in y) {
    if (x.len() == 0)
      error("both iterables must have same number of elements");
    t = tuple(2);
    t(0) = x.shift();
    t(1) = b;
    l.append(t);
  }
  if (x.len() != 0)
    error("both iterables must have same number of elements");
  return l;
}

// 'in' element test
in_fn = fn (a, iterable:b) {
  // checks whether a is in b
  for (x in b)
    if (a==x) return true;
  return false;
};

// what is a pattern?
//   pattern = new(type);     // in rha_init.c
//   pattern.proto = new();   // in rha_init.c
// a pattern constructor

// what is comparable?
comparable = new(type);
comparable.check = fn (x) {
  // check here whether x can be argument of cmp
  //  try {
  //  cmp(x, x)
  // }
  //catch (xxx) {
  //  return false;
  /// }
  //return true;
  return true;
}


//////////////////
// EXPERIMENTAL //
//////////////////
pretty(code) = {
  if (tuple:code) {
    if (code(0) == \plus_sym)
      s = pretty(code(1)) + " + " + pretty(code(1));
    else if (code(0) == \minus_sym)
      s = pretty(code(1)) + " - " + pretty(code(1));
    else if (code(0) == \times_sym)
      s = pretty(code(1)) + " * " + pretty(code(1));
    else if (code(0) == \divide_sym)
      s = pretty(code(1)) + " + " + pretty(code(1));
    else
      error("(pretty) don't know how to pretty print that");
    s = "(" + s + ")";
  }
  else
    s = string(code);
  return s;
}

gradient(f, var) = {
  code = diff(f.fn_data(0).fnbody, var);
  g = new();
  g.fn_data = list().push(clone(f.fn_data(0)));
  g.fn_data(0).fnbody = code;
  return g;
}

diff(code, var) = {
  if (code == var)
    return 1;
  else if (tuple:code) {
    f = code(0);
    if (f == (\plus_fn)) {
      return tuple:[(\plus_fn), diff(code(1), var), diff(code(2), var)];
    }
    if (f == (\minus_fn)) {
      return tuple:[(\minus_fn), diff(code(1), var), diff(code(2), var)];
    }
    if (f == (\times_fn)) {
      t1 = tuple:[(\times_fn), diff(code(1), var), code(2)];
      t2 = tuple:[(\times_fn), code(1), diff(code(2), var)];
      return tuple:[(\plus_fn), t1, t2];
    }
    if (f == (\divide_fn)) {
      tt1 = tuple:[(\times_fn), diff(code(1), var), code(2)];
      tt2 = tuple:[(\times_fn), code(1), diff(code(2), var)];
      t1 = tuple:[(\minus_fn), t1, t2];
      t2 = tuple:[(\times_fn), code(2), code(2)];
      return tuple:[(\divide_fn), t1, t2];
    }
  }
  else
    return 0;
}
