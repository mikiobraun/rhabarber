
lookup(x, sym.proto)

global.modules.eval.eval
global.modules.int.abs
global.modules.int_fn.abs
global.modules.object.new
global.modules.tuple_fn.new

// core stuff
new = global.modules.object.new;

// symbol stuff
symbol = new();
symbol.new = global.modules.symbol_fn.new;
symbol.proto = symbol.new("");

equal(symbol:s, symbol:t) = global.modules.symbol.equal(s, t);

equal = fn (s, t) {
    ....
}


// tuple stuff
tuple = new();
tuple.new = global.modules.tuple_fn.new;
tuple.proto = tuple.new(0);
tuple.proto.len = fn () global.modules.tuple_fn.len(this);

t = tuple.new(5);
t.len()


// problem with curlied brackets:
// we want that there is no ';' necessary at the end of some
// expressions, e.g.
f(x) = {
  return 2*x;
}
if (x>0) { 
  deliver f(17)
}
else f(42);

// however, the problem is that in this example we can't decide
// whether the expression for 'f' goes on with keyword 'if' or not.
// Only if we know that 'if' starts a new one we would.  


//PRULES
// how to check whether something is a prule
prule.check = fn (x) hasslot(x, \priority);
// we assume that a prule translates an expression into a function
// call

//MACROS
m = macro (x, y) y*x;
// a macro is a function with the additional slot 'ismacro', which can
// contain anything...


// some random ideas...
fib(0) = 1
fib(1) = 1
fib(n) = fib(n-1) + fib(n-2)

f = new()
f += fn (x) 2*x;

assign_mc(local, \x, 17)      -> assign
assign_mc(local, \f(x), 17)   -> assign_fn(local, \f(x), 17)
assign_mc(local, \a.x, 17)    -> assign_mc(a, \x, 17)
assign_mc(local, \a.f(x), 17) -> assign_mc(a, \f(x), 17)


a = array(10)
a(1) = 7

f(x) = 2 * x;

is equivalent to:

f.call_rhs = new();
f.call_rhs.argnames = (\x,);
f.call_rhs.scope = local;
f.call_rhs.fnbody = \2*x;

f.call_lhs = magic_fct_extend;



     // lists and tuples and all that
     // do return the value of the last expression
