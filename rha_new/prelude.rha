// (1) first pull some of the functions to the global scope

// the only stuff that exists in 'root' is:

// (1.1) right now we can't even do assignments like 'x=1'
modules.object.assign(root, \assign, modules.object.assign);

// (1.2) let's get more stuff from the object module
new    = modules.object.new;
ls     = modules.object.ls;
new    = modules.object.new;
has    = modules.object.has;
lookup = modules.object.lookup;
clone  = modules.object.clone;
addr   = modules.object.addr;
ptype  = modules.object.ptypename;
run    = modules.core.run_fn;

// functions for prules
if_fn      = modules.core.if_fn;
fn_fn      = modules.core.fn_fn;
for_fn     = modules.core.for_fn;
while_fn   = modules.core.while_fn;
try_fn     = modules.core.try_fn;
//colon_fn   = modules.core.colon_fn;
literal    = modules.core.literal;
return_fn  = modules.core.return_fn;
deliver_fn = modules.core.deliver_fn;
break_fn   = modules.core.break_fn;
print      = modules.object.print_fn;


// test (for convenience)
runtest = fn () run(root, "test.rha");

// temporarily for testing purposes (as long as we have to overloaded)
inc             = modules.object.inc;
dec             = modules.object.dec;
inc_copy        = modules.object.inc_copy;
dec_copy        = modules.object.dec_copy;
plus_fn         = modules.object.plus_fn;
neg_fn          = modules.object.neg_fn;
minus_fn        = modules.object.minus_fn;
times_fn        = modules.object.times_fn;
divide_fn       = modules.object.divide_fn;
equalequal_fn   = modules.object.equalequal_fn;
notequal_fn     = modules.object.notequal_fn;
less_fn         = modules.object.less_fn;
lessequal_fn    = modules.object.lessequal_fn;
greater_fn      = modules.object.greater_fn;
greaterequal_fn = modules.object.greaterequal_fn;
and_fn          = modules.core.and_fn;
or_fn           = modules.core.or_fn;

// code for testing
test = fn (name) {
  t = new();
  t.name = name;
  t.failure = 0;
  t.success = 0;
  t.check = fn (cond) if (cond) this.success++ else this.failure++;
  t.summarize = fn () print("[test]", this.name, 
			    this.success, "PASSED and",
			    this.failure, "FAILED");
  return t;
};

// proxy stuff
proxy = fn (s) root.modules.core.proxy_fn(this, s);


// add functions to the tuple prototype
tuple.proto.len = fn () modules.tuple_fn.tuple_len(this);
tuple.proto.set = fn (i, x) modules.tuple_fn.tuple_set(this, i, x);
tuple.proto.get = fn (i) modules.tuple_fn.tuple_get(this, i);
// a simple constructor for tuples is defined by:
tuple.new = modules.tuple_fn.tuple_new;
// this allows stuff like: t = tuple.new(4);
// however, let's try to be fancy and make 'tuple' a function itself:
tuple.scope = local;
tuple.argnames = modules.tuple_fn.tuple_new(1);
tuple.argnames.set(0, \n);
tuple.fnbody = \modules.tuple_fn.tuple_new(n);
tuple.proto.iter = fn () {
  i = new();
  i.counter = 0;
  i.tuple = this;
  i.done = fn () i.counter == i.tuple.len();
  i.next = fn () this.counter++;
  i.get = fn () this.tuple.get(this.counter);
  return i;
};

// list stuff
list.new = modules.list_fn.list_new;
list.scope = local;
list.argnames = tuple(0);
list.fnbody = \modules.list_fn.list_new();
list.proto.len      = fn () modules.list_fn.list_len(this);
list.proto.copy     = fn () modules.list_fn.list_copy(this);
list.proto.append   = fn (x) modules.list_fn.list_append(this, x);
list.proto.prepend  = fn (x) modules.list_fn.list_prepend(this, x);
list.proto.extend   = fn (l) modules.list_fn.list_extend(this, l);
list.proto.to_tuple = fn () modules.list_fn.list_to_tuple(this);
list.proto.iter     = fn () {
  i = modules.list_fn.list_begin(this);
  i.next = fn () modules.list_fn.list_next(this);
  i.done = fn () modules.list_fn.list_done(this);
  i.get  = fn () modules.list_fn.list_get(this);
  return i;
};

// symbol stuff
// usually we can create symbol with quote, e.g. '\x', however
// operators can only be created by 'symbol("+")'
symbol.scope = local;
symbol.argnames = tuple(1);
symbol.argnames.set(0, \name);
symbol.fnbody = \modules.symbol_fn.symbol_new(name);


// 'in' element test
in_fn = fn (a, b) {
  // checks whether a is in b
  for (x in b)
    if (a==x) return true;
  return false;
};

// colon

//colon_fn = fn (a, b) {
//  return b;
//
//  check = lookup(a, \check);
//  if (check != void) {
//    // perform type check
//    return check(b);
//  };
//  if (int.check(a) && int.check(b)) {
//    if (a > b) return tuple(0);
//    t = tuple(b-a);
//    k = a;
//    while (k < b) t.set(k-a, k);
//    return t;
//  }
//}

// what is an integer?
//int.check = fn (x) return ptype(x)=="int";

// what is a prule?
//prule.check = fn (x) {
//     if (!has(x, \callable)) return false;
//     if (!has(x, \priority)) return false;
//     return true;
//   }

// what is a function?
// note that builtin functions should also have their stuff available
// in \callable!
//   fn.check = fn (x) {
//     if (!has(x, \callable)) return false;
//     return true;
//   }

// what is a macro?
//   macro.check = fn (x) {
//     if (!fn.check(x)) return false;
//     if (!has(x, \ismacro)) return false;
//     return true;
//   }

// what is iterable?
//   iterable.check = fn (x) {
//     if (!has(x, \iterable)) return false;
//     i = x.iterable;
//     if (!has(i, \begin)) return false;
//     if (!has(i, \done)) return false;
//     if (!has(i, \next)) return false;
//     if (!has(i, \get)) return false;
//     return true;
//   }

// what is an exception?
// any object can be an exception, however if it has the slot 'msg' it
// will be shown
