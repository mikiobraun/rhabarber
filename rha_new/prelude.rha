// (1) first pull some of the functions to the global scope

// the only stuff that exists in 'root' is:

// (1.1) work done by rha_init() in rha_init.c
//
//   type = new();
//   type.proto = type;
//   type.check = fn (x) modules.object.check(this, x);
//
//   bool.check = fn (x) modules.object.pcheck(this, x);
//   int.check = fn (x) modules.object.pcheck(this, x);
//   ...
//
//   pattern = clone(type);
//   pattern.proto = new();
//   pattern(type:t, symbol:s) = {
//     p = new(pattern);
//     p.patterntype = t;
//     p.patternsymbol = s;
//     return p;
//   }
//
//   assign = modules.object.assign;
//   extend = modules.object.extend;


// (1.2) more essential stuff
new      = modules.object.new;
// let's overloaded that builtin function!!!
new(type:t) = {
  x = new(); // creates new object
  x.parent = t.proto;
  return x;
}
// note that if 't' doesn't have a slot 'proto' this code raises an 
// look-up-failed exception, which is the intended behavior. 
// to get an empty object with a certain parent pointer 
// use 'clone'
clone    = modules.object.clone;
rm       = modules.object.rm;
ls       = modules.object.ls;
new      = modules.object.new;
has      = modules.object.has;
lookup   = modules.object.lookup;
lookup_local = modules.object.lookup_local;
location = modules.object.location;
clone    = modules.object.clone;
addr     = modules.object.addr;
run      = modules.core.run_fn;
error    = modules.messages.error;
warning  = modules.messages.warning;

// take care of 'syntactic functions', which generate no frame to return from
no_frame(f) = { f.fn_data.no_frame = true; f };

// (1.3) functions that are accessed after applying prules
if_fn      = no_frame(modules.core.if_fn); 
fn_fn      = modules.core.fn_fn;
macro_fn   = modules.core.macro_fn;
for_fn     = no_frame(modules.core.for_fn); 
while_fn   = no_frame(modules.core.while_fn);
try_fn     = modules.core.try_fn; 
literal    = modules.core.literal;
return_fn  = no_frame(modules.core.return_fn);
deliver_fn = no_frame(modules.core.deliver_fn);
break_fn   = no_frame(modules.core.break_fn); 
throw_fn   = no_frame(modules.core.throw_fn);
print      = modules.object.print_fn;

// (1.4) proxy and other useful stuff
proxy = fn (s) root.modules.core.proxy_fn(this, s);
run(filename) = run(root, filename);
defined = macro (symbolname) has(local, \symbolname);
undefined = macro( symbolname) has(local, symbolname);
//assert = macro (cond) if (!cond) throw to_string(cond) + " FAILED";

// (1.5) macros for writing tests (see test.rha for an example)
test = macro (x) {
  failure = 0;
  success = 0;
  name = x;
}
check = macro (x) {
  if (eval(local, x))
    success++;
  else {
    print("FAILED:" ,\x);
    failure++;
  }
}
summarize = macro () {
  if (failure > 0)
    print ("[test]", failure, "/", failure+success, "SOME FAILED", name);
  else
    print ("[test]", success, "/", failure+success, "ALL PASSED", name);
}
runtest = fn () run(root, "test.rha");

// (1.6) symbol stuff
// usually we can create symbol with quote, e.g. '\x', however
// operators can only be created by 'symbol("+")'
symbol(name) = modules.symbol_fn.symbol_new(name);


// typing stuff

// type    = new();        // in rha_init.c (used by 'ptype')
// type.proto = type;
// type.check = fn (x) modules.object.check(this, x)
type.name  = "type";
type.to_string = fn () this.name;
type.type  = type;         // 'type' is of type 'type'
typename = fn (x) x.type.name;     // try 'typename(17)'
	    // note that 'type(x) = x.type.name' is not a good idea,
	    // since then also 'bool(17)' will do '17.type.name'
	    // instead of casting.

// comments:
// (i)   'int', 'real' are examples of types with prototypes
// (ii)  'type', 'ptype' are examples of type-types.
//       note that prototypes of type-types are the 
//       types themselves.
// (iii) 'iterable', 'callable' are examples of types without a
//       prototype slot, since they measure properties.  They are
//       merely like guards in Haskell.
// (iv)  'comparable' does have a prototype slot, but instantiating
//       it, does note create something useful since the
//       implementation of 'cmp' is missing.

// how to subtype
// note that subtypes of a type 't' can appear everywhere where 't'
// can appear.  the usual way to subtype is by 'clone', however this
// doesn't work for types, but only non-types.
subtype = fn (t) {
  st = clone(t);
  if (has(t, \proto))
    st.proto = clone(t.proto);
  return st;
}

// is 'x' an instance of a subtype of 't'?
isa = fn (x, t) {
  // 'location' allows us to jump to the relevant objects in the
  // parent path
  while (true) {
    x = location(x, \type);
    if (x.type == t) return true;
    if (!has(x, \parent)) return false;
    x = x.parent;
  }
}

// colon can be used for typechecks and to generate tuple
colon_fn = fn (a, b) {
  // is 'a' a type?
  if (type.check(a))
    // yes, perform type check
    return a.check(b);
  // otherwise generate a tuple
  // later on, this should be a true generator using 'yield'
  if (int.check(a) && int.check(b)) {
    if (a > b) return tuple(0);
    t = tuple(b-a);
    k = a;
    while (k < b) {
      t.set(k-a, k);
      k += 1;  // note that k++ is wrong since it changes 'a'
    }
    return t;
  }
  throw "either 0:5 or int:x";
}


// == and != are special
// the problem with overloading here is that type checking might use
// certain function which are overloaded themselves, which needs to be
// resolved with type checking and so on...
equalequal_fn = modules.object.equalequal_fn;
notequal_fn   = modules.object.notequal_fn;

// temporarily for testing purposes
inc             = modules.object.inc;
dec             = modules.object.dec;
inc_copy        = modules.object.inc_copy;
dec_copy        = modules.object.dec_copy;
to_string       = modules.object.to_string;


// patterns
pattern.proto.string = fn () this.patterntype + ":" + this.patternsymbol;

// types
less_fn(type:x, type:y) = x:y;
or_fn(type:t1, type:t2) = {
  t = new(type);
  t.check = fn (x) t1:x || t2:x;
  return t;
}
plus_fn(type:t1, type:t2) = {
  // (t1+t2):x  == t1:x && t2:x
  t = new(type);
  t.check = fn (x) t1:x && t2:x;
  return t;
}
times_fn(type:t1, type:t2) = { 
  // int*real*string   (tuples of types)
  t = new(type); 
  t.check = fn (x) tuple.check(x) 
                   && x.len() == 2 
                   && t1:x(0) && t2:x(1); 
  return t;
}


// bools
not_fn(bool:x)         = modules.bool_fn.bool_not(x);
and_fn(bool:x, bool:y) = modules.bool_fn.bool_and(x, y);
or_fn(bool:x, bool:y)  = modules.bool_fn.bool_or(x, y);
//equalequal_fn(bool:x, bool:y) = modules.bool_fn.bool_equalequal(x, y);


// strings
//string((bool||int||real||symbol||tuple||list||address):x) = modules.object.to_string(x);
plus_fn(string:x, string:y) = modules.string_fn.string_concat(x, y);
string.proto.len = fn () modules.string_fn.string_len(this);
//equalequal_fn(string:x, string:y) = modules.string_fn.string_equalequal(x, y);


//----------------------------------------------------------------------
// integers
plus_fn(int:x, int:y) = modules.int_fn.int_plus(x, y);
neg_fn(int:x) = modules.int_fn.int_neg(x);
minus_fn(int:x, int:y) = modules.int_fn.int_minus(x, y);
times_fn(int:x, int:y) = modules.int_fn.int_times(x, y);
divide_fn(int:x, int:y) = modules.int_fn.int_divide(x, y);
less_fn(int:x, int:y) = modules.int_fn.int_less(x, y);
lessequal_fn(int:x, int:y) = modules.int_fn.int_lessequal(x, y);
greater_fn(int:x, int:y) = modules.int_fn.int_greater(x, y);
greaterequal_fn(int:x, int:y) = modules.int_fn.int_greaterequal(x, y);
int(real:x) = modules.int_fn.int_cast(x);  // try 'int(3.14)'
//equalequal_fn(int:x, int:y) = modules.int_fn.int_equalequal(x, y);


//----------------------------------------------------------------------
// tuples
tuple(int:len) = modules.tuple_fn.tuple_new(len);
tuple(list:l) = modules.list_fn.list_to_tuple(l);
plus_fn(tuple:a, tuple:b) = {
  l = list();
  for (x in a)
    l.push(x);
  for (x in b)
    l.push(x);
  return tuple(l);
}
tuple.proto.len = fn () modules.tuple_fn.tuple_len(this);
tuple.proto.set = fn (i, x) modules.tuple_fn.tuple_set(this, i, x);
tuple.proto.get = fn (i) modules.tuple_fn.tuple_get(this, i);
tuple.proto.iter = fn () {
  i = new();
  i.counter = 0;
  i.tuple = this;
  i.done = fn () i.counter == i.tuple.len();
  i.next = fn () this.counter++;
  i.get = fn () this.tuple.get(this.counter);
  return i;
}
rm(tuple.proto, \fn_data); // to make sure we get a new implementation
rm(tuple.proto, \extend);  // otherwise we can't overload
// member access, e.g. t(0)
tuple.proto(int:i) = static.get(i); // member access, e.g. t(0)
// slices, e.g. t(1:3)
tuple.proto(tuple:idx) = {
  t = tuple(idx.len());
  j = 0;
  for (i in idx)
    t.set(j++, static.get(i));
  return t;
}
// member replace, e.g. t(0)=17
tuple.proto.extend = fn (signature, scope, rhs) {
  if (signature.len() != 1)
    error("(tuple) invalid tuple index");
  index = signature(0).patternsymbol;
  value = eval(scope, rhs);
  this.set(index, value);
  return value;
}

//----------------------------------------------------------------------
// lists
list() = modules.list_fn.list_new();
list(tuple:t) = modules.tuple_fn.tuple_to_list(t);
list.proto.len      = fn () modules.list_fn.list_len(this);
list.proto.copy     = fn () modules.list_fn.list_copy(this);
list.proto.append   = fn (x) modules.list_fn.list_append(this, x);
list.proto.prepend  = fn (x) modules.list_fn.list_prepend(this, x);
//  note that right now we have a name clash for 'extend' with the one
//  that is lookup for stuff like:    list(17)
//list.proto.extend   = fn (l) modules.list_fn.list_extend(this, l);
plus_fn(list:a, list:b) = modules.list_fn.list_extend(a, b);
list.proto.first    = fn () modules.list_fn.list_first(this);
list.proto.last     = fn () modules.list_fn.list_last(this);
list.proto.pop      = fn () modules.list_fn.list_poplast(this);
list.proto.push     = fn (...) for (x in args) modules.list_fn.list_append(this, x);
list.proto.shift    = fn () modules.list_fn.list_popfirst(this);
list.proto.unshift  = fn (...) for (x in args) modules.list_fn.list_prepend(this, x);
list.proto.to_tuple = fn () modules.list_fn.list_to_tuple(this);
list.proto.iter     = fn () {
  i = modules.list_fn.list_begin(this);
  i.next = fn () modules.list_fn.list_next(this);
  i.done = fn () modules.list_fn.list_done(this);
  i.get  = fn () modules.list_fn.list_get(this);
  return i;
}
rm(list.proto, \fn_data);
list.proto(int:i) = {
  if (0 <= i < static.len()) {
    iterator = static.iter();
    for (count in 0:i)
      iterator.next();
    return iterator.get();
  }
  else
    error("(list) index out of bounds");
}



// 'in' element test
in_fn = fn (a, b) {
  // checks whether a is in b
  for (x in b)
    if (a==x) return true;
  return false;
};

// what is a pattern?
//   pattern = new(type);     // in rha_init.c
//   pattern.proto = new();   // in rha_init.c
// a pattern constructor
pattern(symbol:s) = {
  p = instance(pattern);
  p.patternsymbol = s;
  return p;
}
pattern(type:x, symbol:s) = {
  p = pattern(s);
  p.patterntype = x;
  return p;
}
pattern.proto.to_string() = {
  if (this == pattern.proto)
    return "<pattern.proto>";
  s = to_string(this.patternsymbol);
  if (has(this, \patterntype))
    s = to_string(this.patterntype)+":"+s;
  return s;
}

// what is iterable?
iterable = new(type);
iterable.check = fn (x) {
  if (!has(x, \iter)) return false;
  i = x.iter();
  if (!has(i, \done)) return false;
  if (!has(i, \next)) return false;
  if (!has(i, \get)) return false;
  return true;
}

// what is comparable?
comparable = new(type);
comparable.check = fn (x) {
  // check here whether x can be argument of cmp
  //  try {
  //  cmp(x, x)
  // }
  //catch (xxx) {
  //  return false;
  /// }
  //return true;
  return true;
}
