// (1) first pull some of the functions to the global scope

// the only stuff that exists in 'root' is:

// (1.1) work done by rha_init() in rha_init.c
//
//   type = new();
//   type.proto = type;
//   type.check = fn (x) modules.object.check(this, x);
//
//   bool.check = fn (x) modules.object.pcheck(this, x);
//   int.check = fn (x) modules.object.pcheck(this, x);
//   ...
//
//   pattern = clone(type);
//   pattern.proto = new();
//   pattern(type:t, symbol:s) = {
//     p = new(pattern);
//     p.patterntype = t;
//     p.patternsymbol = s;
//     return p;
//   }
//
//   assign = modules.object.assign;
//   extend = modules.object.extend;


// (1.2) more essential stuff
new      = modules.object.new;
// let's overloaded that builtin function!!!
new(type:t) = {
  x = new(); // creates new object
  x.parent = t.proto;
  return x;
}
// note that if 't' doesn't have a slot 'proto' this code raises an 
// look-up-failed exception, which is the intended behavior. 
// to get an empty object with a certain parent pointer 
// use 'clone'
eval(x)  = eval(this, x);
clone    = modules.object.clone;
rm       = modules.object.rm;
ls       = modules.object.ls;
new      = modules.object.new;
has      = modules.object.has;
lookup   = modules.object.lookup;
lookup_local = modules.object.lookup_local;
location = modules.object.location;
clone    = modules.object.clone;
addr     = modules.object.addr;
run      = modules.core.run_fn;
error    = modules.messages.error;
warning  = modules.messages.warning;
resolve  = modules.parse.resolve;

// take care of 'syntactic functions', which generate no frame to return from
no_frame(f) = { f.fn_data.no_frame = true; f };

// (1.3) functions that are accessed after applying prules
if_fn      = no_frame(modules.core.if_fn); 
fn_fn      = modules.core.fn_fn;
macro_fn   = modules.core.macro_fn;
for_fn     = no_frame(modules.core.for_fn); 
while_fn   = no_frame(modules.core.while_fn);
try_fn     = modules.core.try_fn; 
return_fn  = no_frame(modules.core.return_fn);
deliver_fn = no_frame(modules.core.deliver_fn);
break_fn   = no_frame(modules.core.break_fn); 
throw_fn   = no_frame(modules.core.throw_fn);
print      = modules.object.print_fn;

// (1.4) proxy and other useful stuff
proxy = fn (s) root.modules.core.proxy_fn(this, s);
run(filename) = run(root, filename);
defined = macro (symbolname) has(local, \symbolname);
undefined = macro( symbolname) has(local, symbolname);
//assert = macro (cond) if (!cond) throw to_string(cond) + " FAILED";

// (1.5) macros for writing tests (see test.rha for an example)
test = macro (x) {
  failure = 0;
  success = 0;
  name = x;
}
check = macro (x) {
  if (eval(local, x))
    success++;
  else {
    print("FAILED: " ,\x);
    failure++;
  }
}
summarize = macro () {
  if (failure > 0)
    print ("[test] ", failure, "/", failure+success, "\t SOME FAILED in ", name);
  else
    print ("[test] ", success, "/", failure+success, "\t ALL PASSED  in ", name);
}
runtest = fn () run(root, "test.rha");



// typing stuff

// type    = new();        // in rha_init.c (used by 'ptype')
// type.proto = type;
// type.check = fn (x) modules.object.check(this, x)
type.name  = "type";
type.string = fn () this.name;
type.type  = type;         // 'type' is of type 'type'
typename = fn (x) x.type.name;     // try 'typename(17)'
	    // note that 'type(x) = x.type.name' is not a good idea,
	    // since then also 'bool(17)' will do '17.type.name'
	    // instead of casting.

// comments:
// (i)   'int', 'real' are examples of types with prototypes
// (ii)  'type', 'ptype' are examples of type-types.
//       note that prototypes of type-types are the 
//       types themselves.
// (iii) 'iterable', 'callable' are examples of types without a
//       prototype slot, since they measure properties.  They are
//       merely like guards in Haskell.
// (iv)  'comparable' does have a prototype slot, but instantiating
//       it, does note create something useful since the
//       implementation of 'cmp' is missing.

// how to subtype
// note that subtypes of a type 't' can appear everywhere where 't'
// can appear.  the usual way to subtype is by 'clone', however this
// doesn't work for types, but only non-types.
subtype = fn (t) {
  st = clone(t);
  if (has(t, \proto))
    st.proto = clone(t.proto);
  return st;
}

// is 'x' an instance of a subtype of 't'?
isa = fn (x, t) {
  // 'location' allows us to jump to the relevant objects in the
  // parent path
  while (true) {
    x = location(x, \type);
    if (x.type == t) return true;
    if (!has(x, \parent)) return false;
    x = x.parent;
  }
}

// colon can be used for typechecks and to generate tuple
colon_fn = fn (a, b) {
  // is 'a' a type?
  if (type.check(a))
    // yes, perform type check
    return a.check(b);
  // otherwise generate a tuple
  // later on, this should be a true generator using 'yield'
  if (int.check(a) && int.check(b)) {
    if (a > b) return tuple(0);
    t = tuple(b-a);
    k = a;
    while (k < b) {
      t.set(k-a, k);
      k += 1;  // note that k++ is wrong since it changes 'a'
    }
    return t;
  }
  throw "either 0:5 or int:x";
}


// == and != are special
// the problem with overloading here is that type checking might use
// certain function which are overloaded themselves, which needs to be
// resolved with type checking and so on...
equalequal_fn = modules.object.equalequal_fn;
notequal_fn   = modules.object.notequal_fn;

// complex literal
literal = fn (env, pl) list.literal(env, pl);
split_parselist = fn (list:symlist, env, list:pl) {
  if (symlist.len() == 0)
    return resolve(env, pl);
  // else we need to split by the next symbol
  split = symlist.shift();
  sink = list();
  part = list();
  for (x in pl) {
    if (x == split) {
      // split here
      print(part);
      sink.push(split_parselist(symlist, env, part));
      part = list();
    }
    else
      part.push(x);
  }
  print(part);
  sink.push(split_parselist(symlist, env, part));
  symlist.unshift(split);
  return sink;
}


// temporarily for testing purposes
inc             = modules.object.inc;
dec             = modules.object.dec;
inc_copy        = modules.object.inc_copy;
dec_copy        = modules.object.dec_copy;
to_string       = modules.object.to_string;

// fn_data_proto
// note that there is no 'fn_data' in root, since otherwise 'root'
// would be callable.  thus we only have 'fn_data_proto' which allows
// us to get a pretty 'fn_data' view and other stuff
fn_data_proto.parent = list.proto;   // basically, fn_data is a
                                     // subtype of 'list'
fn_data_proto.string = fn () {
  if (fn_data_proto == this)
    return "<fn_data prototype>";
  s = "";
  i = 0;
  for (x in this) {
    if (i > 0) s += "\n";
    s += string(i++) + " ";
    s += string(x);
  }
  return s;
}


// implemention_proto
implementation_proto.string = fn () {
  s = "";
  if (builtin:this.fnbody)
    s += "builtin(";
  else
    s += "function(";
  if (has(this, \signature)) {
    j = 0;
    for (y in this.signature) {
      if (j++ > 0) s += ", ";
      s += string(y);
    }
  }
  if (has(this, \varargs) && lookup(this, \varargs))
    s += ", ...";
  return s + ")";
}

// symbol
symbol.proto.string = fn () modules.symbol_fn.symbol_to_string(this);
symbol(name) = modules.symbol_fn.symbol_new(name);
//equalequal_fn(symbol:x, symbol:y) = modules.symbol_fn.symbol_equalequal(x, y);

// pattern
pattern.proto.string = fn () {
  s = "";
  if (has(this, \patterntype))
    s += string(this.patterntype) + ":";
  else
    s += "object:";
  if (has(this, \patternsymbol))
    s += string(this.patternsymbol);
  else
    s += "<nosym>";
  return s;
}

// types
less_fn(type:x, type:y) = x:y;
or_fn(type:t1, type:t2) = {
  t = new(type);
  t.check = fn (x) t1:x || t2:x;
  return t;
}
plus_fn(type:t1, type:t2) = {
  // (t1+t2):x  == t1:x && t2:x
  t = new(type);
  t.check = fn (x) t1:x && t2:x;
  return t;
}
times_fn(type:t1, type:t2) = { 
  // int*real*string   (tuples of types)
  t = new(type); 
  t.check = fn (x) tuple.check(x) 
                   && x.len() == 2 
                   && t1:x(0) && t2:x(1); 
  return t;
}


// builtins
builtin.proto.string = fn () modules.object.builtin_to_string(this);


// addresses
address.proto.string = fn () modules.object.address_to_string(this);


// bools
bool.proto.string      = fn () modules.bool_fn.bool_to_string(this);
not_fn(bool:x)         = modules.bool_fn.bool_not(x);
and_fn(bool:x, bool:y) = modules.bool_fn.bool_and(x, y);
or_fn(bool:x, bool:y)  = modules.bool_fn.bool_or(x, y);
//equalequal_fn(bool:x, bool:y) = modules.bool_fn.bool_equalequal(x, y);


// strings
string.proto.string         = fn () modules.string_fn.string_to_string(this);
string()                    = "<somescope>";
string(x)                   = modules.object.to_string(x);
plus_fn(string:x, string:y) = modules.string_fn.string_concat(x, y);
string.proto.len            = fn () modules.string_fn.string_len(this);
//equalequal_fn(string:x, string:y) = modules.string_fn.string_equalequal(x, y);


//----------------------------------------------------------------------
// integers
int.proto.string              = fn () modules.int_fn.int_to_string(this);
apostrophe_fn(int:x) = x;
plus_fn(int:x, int:y)         = modules.int_fn.int_plus(x, y);
neg_fn(int:x)                 = modules.int_fn.int_neg(x);
minus_fn(int:x, int:y)        = modules.int_fn.int_minus(x, y);
times_fn(int:x, int:y)        = modules.int_fn.int_times(x, y);
divide_fn(int:x, int:y)       = modules.int_fn.int_divide(x, y);
less_fn(int:x, int:y)         = modules.int_fn.int_less(x, y);
lessequal_fn(int:x, int:y)    = modules.int_fn.int_lessequal(x, y);
greater_fn(int:x, int:y)      = modules.int_fn.int_greater(x, y);
greaterequal_fn(int:x, int:y) = modules.int_fn.int_greaterequal(x, y);
int(real:x)                   = modules.int_fn.int_cast(x);  
exp(int:x) = modules.real_fn.real_exp(real(x));
sin(int:x) = modules.real_fn.real_sin(real(x));
cos(int:x) = modules.real_fn.real_cos(real(x));
//equalequal_fn(int:x, int:y) = modules.int_fn.int_equalequal(x, y);

//----------------------------------------------------------------------
// reals
real.proto.string               = fn () modules.real_fn.real_to_string(this);
apostrophe_fn(real:x) = x;
plus_fn(real:x, real:y)         = modules.real_fn.real_plus(x, y);
plus_fn(int:x, real:y)          = modules.real_fn.real_plus(real(x), y);
plus_fn(real:x, int:y)          = modules.real_fn.real_plus(x, real(y));
neg_fn(real:x)                  = modules.real_fn.real_neg(x);
minus_fn(real:x, real:y)         = modules.real_fn.real_minus(x, y);
minus_fn(int:x, real:y)          = modules.real_fn.real_minus(real(x), y);
minus_fn(real:x, int:y)          = modules.real_fn.real_minus(x, real(y));
times_fn(real:x, real:y)         = modules.real_fn.real_times(x, y);
times_fn(int:x, real:y)          = modules.real_fn.real_times(real(x), y);
times_fn(real:x, int:y)          = modules.real_fn.real_times(x, real(y));
divide_fn(real:x, real:y)         = modules.real_fn.real_divide(x, y);
divide_fn(int:x, real:y)          = modules.real_fn.real_divide(real(x), y);
divide_fn(real:x, int:y)          = modules.real_fn.real_divide(x, real(y));
less_fn(real:x, real:y)         = modules.real_fn.real_less(x, y);
lessequal_fn(real:x, real:y)    = modules.real_fn.real_lessequal(x, y);
greater_fn(real:x, real:y)      = modules.real_fn.real_greater(x, y);
greaterequal_fn(real:x, real:y) = modules.real_fn.real_greaterequal(x, y);
real(int:x)                     = modules.real_fn.real_cast(x);  
exp(real:x) = modules.real_fn.real_exp(x);
sin(real:x) = modules.real_fn.real_sin(x);
cos(real:x) = modules.real_fn.real_cos(x);
//equalequal_fn(real:x, real:y) = modules.real_fn.real_equalequal(x, y);




//----------------------------------------------------------------------
// matrices
mat.literal(env, list:pl) = {
  x = split_parsetree(list().push(symbol(";"), symbol(",")), env, pl);
  rows = x.len();
  for (row in x) {
    print("not yet");
  }
}
rand(int:rows, int:cols) = modules.mat_fn.mat_rand(rows, cols);
randn(int:rows, int:cols) = modules.mat_fn.mat_randn(rows, cols);
apostrophe_fn(mat:x) = modules.mat_fn.mat_transpose(x);
mat.proto.string = fn () modules.mat_fn.mat_to_string(this);
eye(int:n) = modules.mat_fn.mat_eye(n);
mat(int:rows, int:cols) = modules.mat_fn.mat_new(rows, cols);
mat.copy = fn () modules.mat_fn.mat_copy(this);
mat.proto.rows = fn () modules.mat_fn.mat_rows(this);
mat.proto.cols = fn () modules.mat_fn.mat_cols(this);
mat.proto.len  = fn () modules.mat_fn.mat_len(this);
mat.proto.getl = fn (int:i) modules.mat_fn.mat_getl(this, i);
mat.proto.setl = fn (int:i, real:v) modules.mat_fn.mat_setl(this,i, v);
mat.proto.get  = fn (int:i, int:j) modules.mat_fn.mat_get(this, i, j);
mat.proto.set  = fn (int:i, int:j, real:v) modules.mat_fn.mat_get(this, i, j, v);
mat.proto.norm = fn () modules.mat_fn.mat_norm(this);
mat.proto.max  = fn () modules.mat_fn.mat_max(this);
mat.proto.min  = fn () modules.mat_fn.mat_min(this);
mat.proto.scale = fn (real:v) modules.mat_fn.mat_scale(this, v);
mat.proto.repmat = fn (int:i, int:j) modules.mat_fn.mat_repmat(this, i, j);
mat.proto.reshape = fn (int:i, int:j) modules.mat_fn.mat_reshape(this, i, j);
mat.proto.neg  = fn () modules.mat_fn.mat_minus(this);
plus_fn(mat:x, mat:y)  = modules.mat_fn.mat_plus_mat(x, y);
plus_fn(int:x, mat:y)  = modules.mat_fn.real_plus_mat(real(x), y);
plus_fn(mat:x, int:y)  = modules.mat_fn.mat_plus_real(x, real(y));
plus_fn(mat:x, real:y) = modules.mat_fn.mat_plus_real(x, y);
plus_fn(real:x, mat:y) = modules.mat_fn.real_plus_mat(x, y);
minus_fn(mat:x, mat:y)  = modules.mat_fn.mat_minus_mat(x, y);
minus_fn(int:x, mat:y)  = modules.mat_fn.real_minus_mat(real(x), y);
minus_fn(mat:x, int:y)  = modules.mat_fn.mat_minus_real(x, real(y));
minus_fn(mat:x, real:y) = modules.mat_fn.mat_minus_real(x, y);
minus_fn(real:x, mat:y) = modules.mat_fn.real_minus_mat(x, y);
times_fn(mat:x, mat:y)  = modules.mat_fn.mat_times_mat(x, y);
times_fn(int:x, mat:y)  = modules.mat_fn.real_times_mat(real(x), y);
times_fn(mat:x, int:y)  = modules.mat_fn.mat_times_real(x, real(y));
times_fn(mat:x, real:y) = modules.mat_fn.mat_times_real(x, y);
times_fn(real:x, mat:y) = modules.mat_fn.real_times_mat(x, y);
dottimes_fn(mat:x, mat:y)  = modules.mat_fn.mat_dottimes_mat(x, y);
dottimes_fn(int:x, mat:y)  = modules.mat_fn.real_times_mat(real(x), y);
dottimes_fn(mat:x, int:y)  = modules.mat_fn.mat_times_real(x, real(y));
dottimes_fn(mat:x, real:y) = modules.mat_fn.mat_times_real(x, y);
dottimes_fn(real:x, mat:y) = modules.mat_fn.real_times_mat(x, y);
dotdivide_fn(mat:x, mat:y)  = modules.mat_fn.mat_dotdivide_mat(x, y);
dotdivide_fn(mat:x, int:y)  = modules.mat_fn.mat_divide_real(x, real(y));
dotdivide_fn(mat:x, real:y) = modules.mat_fn.mat_divide_real(x, y);
dotdivide_fn(real:x, mat:y) = modules.mat_fn.real_divide_mat(x, y);
exp(mat:x) = modules.mat_fn.mat_exp(x);
sin(mat:x) = modules.mat_fn.mat_sin(x);
sinc(mat:x) = modules.mat_fn.mat_sinc(x);

//----------------------------------------------------------------------
// tuples
tuple(int:len) = modules.tuple_fn.tuple_new(len);
tuple(list:l) = modules.list_fn.list_to_tuple(l);
plus_fn(tuple:a, tuple:b) = {
  l = list();
  for (x in a)
    l.push(x);
  for (x in b)
    l.push(x);
  return tuple(l);
}
tuple.proto.string = fn () modules.tuple_fn.tuple_to_string(this);
tuple.literal      = fn (env, pl) tuple(list.literal(env, pl));
tuple.proto.len    = fn () modules.tuple_fn.tuple_len(this);
tuple.proto.set    = fn (i, x) modules.tuple_fn.tuple_set(this, i, x);
tuple.proto.get    = fn (i) modules.tuple_fn.tuple_get(this, i);
tuple.proto.iter = fn () {
  i = new();
  i.counter = 0;
  i.tuple = this;
  i.done = fn () i.counter == i.tuple.len();
  i.next = fn () this.counter++;
  i.get = fn () this.tuple.get(this.counter);
  return i;
}
rm(tuple.proto, \fn_data); // to make sure we get a new implementation
rm(tuple.proto, \extend);  // otherwise we can't overload
// member access, e.g. t(0)
tuple.proto(int:i) = static.get(i); // member access, e.g. t(0)
// slices, e.g. t(1:3)
tuple.proto(tuple:idx) = {
  t = tuple(idx.len());
  j = 0;
  for (i in idx)
    t.set(j++, static.get(i));
  return t;
}
// member replace, e.g. t(0)=17
tuple.proto.extend = fn (signature, scope, rhs) {
  if (signature.len() != 1)
    error("(tuple) invalid tuple index");
  index = signature(0).patternsymbol;
  value = eval(scope, rhs);
  this.set(index, value);
  return value;
}

//----------------------------------------------------------------------
// lists
list() = modules.list_fn.list_new();
list(tuple:t) = modules.tuple_fn.tuple_to_list(t);
list.literal(env, list:pl) = split_parselist(list().push(symbol(",")), env, pl);
list.proto.string    = fn () modules.list_fn.list_to_string(this);
list.proto.len       = fn () modules.list_fn.list_len(this);
list.proto.copy      = fn () modules.list_fn.list_copy(this);
list.proto.append    = fn (x) modules.list_fn.list_append(this, x);
list.proto.prepend   = fn (x) modules.list_fn.list_prepend(this, x);
//  note that right now we have a name clash for 'extend' with the one
//  that is lookup for stuff like:    list(17)
//list.proto.extend   = fn (l) modules.list_fn.list_extend(this, l);
plus_fn(list:a, list:b) = modules.list_fn.list_extend(a, b);
list.proto.first    = fn () modules.list_fn.list_first(this);
list.proto.last     = fn () modules.list_fn.list_last(this);
list.proto.pop      = fn () modules.list_fn.list_poplast(this);
list.proto.push     = fn (...) for (x in args) modules.list_fn.list_append(this, x);
list.proto.shift    = fn () modules.list_fn.list_popfirst(this);
list.proto.unshift  = fn (...) for (x in args) modules.list_fn.list_prepend(this, x);
list.proto.to_tuple = fn () modules.list_fn.list_to_tuple(this);
list.proto.iter     = fn () {
  i = modules.list_fn.list_begin(this);
  i.next = fn () modules.list_fn.list_next(this);
  i.done = fn () modules.list_fn.list_done(this);
  i.get  = fn () modules.list_fn.list_get(this);
  return i;
}
rm(list.proto, \fn_data);
list.proto(int:i) = {
  if (0 <= i < static.len()) {
    iterator = static.iter();
    for (count in 0:i)
      iterator.next();
    return iterator.get();
  }
  else
    error("(list) index out of bounds");
}



// 'in' element test
in_fn = fn (a, b) {
  // checks whether a is in b
  for (x in b)
    if (a==x) return true;
  return false;
};

// what is a pattern?
//   pattern = new(type);     // in rha_init.c
//   pattern.proto = new();   // in rha_init.c
// a pattern constructor

// what is iterable?
iterable = new(type);
iterable.check = fn (x) {
  if (!has(x, \iter)) return false;
  i = x.iter();
  if (!has(i, \done)) return false;
  if (!has(i, \next)) return false;
  if (!has(i, \get)) return false;
  return true;
}

// what is comparable?
comparable = new(type);
comparable.check = fn (x) {
  // check here whether x can be argument of cmp
  //  try {
  //  cmp(x, x)
  // }
  //catch (xxx) {
  //  return false;
  /// }
  //return true;
  return true;
}
