2007-08-24  Stefan Harmeling  <harmeling@gmail.com>

	* prules.c (resolve_assign_prule): now assignments to symbols
	still creates assignment, but assignments to calls creates
	extends:

	    x=0          (assign local x 0)
	    a.x=0        (assign a x 0)

	    f(x)=0       (extend local (quote f) (quote (x)) local (quote 0))
	    a.f(x)=0     (extend a     (quote f) (quote (x)) local (quote 0))

	* eval.c (call_rha_fun): added 'static'

	* parse.c (resolve_code_block): now a sequence of commands in
	curly brackets is split after a code block (in curly brackets) if
	not a "second-order-keyword" such as currently 'else' or 'catch'
	is following.  However, this solution is preliminary, since if we
	extend the syntax with new complicated freefix form we need to add
	them here by hand.

	* rha_lexer.l: removed the case with \n  \n that generated a
	semicolon, since now 'resolve_code_block' deals with it.

	* rhabarber.c (main): the outer-most (do_sym 17; 42+42) is now
	dealt with outside the eval function, which makes sense, since it
	only happens in the real-eval-loop.  now typing 'deliver 17' at
	the prompt generates (do_sym (deliver 17)) but doesn't open a
	BLOCK_FRAME and thus issues the correct error.

2007-08-23  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (extend): added extend, which is not done yet and which
	doesn't really extend right now, but should only overwrite an
	existing function definiton.

	* prules.c (resolve_assign_prule): rewritten the whole thing for
	stuff like f(x)=2*x.  However, right now += and friends no longer
	work.  But can be easily put back.

	* tuple_fn.c (tuple_set): now also tuple_set returns the tuple and
	we can do:

	    t = tuple(3).set(0, 17).set(1, 42).set(2, 55);

	* list.rha (fn): added PERL like pop, push, shift, unshift.

	* parse.c (resolve_dots_and_fn_calls): rewrote the whole thing to
	allow magic stuff like:

	     l = list().push(17).push(42);

	* list_fn.c (list_append, list_prepend, list_extend): all of them
	return now the list.

2007-08-23  Mikio Braun  <mikiobraun@gmail.com>

	* object.c (assign): added error message if you try to assign a
	void

2007-08-23  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (to_string): catch the case for 'symbol.proto' which is
	a symbol but has value zero.

	* symbol_fn.c (symbol_name): check for accessing symbol number
	zero.
	

	* rhabarber.c (main): fixed a bug that happens when just pressing
	return at the prompt, now the parse() function might return zero
	which is fine with eval() and fprint("%o").

2007-08-23  Stefan Harmeling  <harmeli@dhcp-153-147.inf.ed.ac.uk>

	* eval.c, rhabarber.c, prules.c, rha_config.pl, object.c, core.c,
	parse.c, eval.c: removed 'void_obj', now 0 is void_obj.  note that
	there is still symbol 'void' which could be internally represented
	by: 
	    object_t void_obj = 0;

	(eval): lookup for void now works...

	* prelude.rha: added for convenience

	    runtest = fn () run(root, "test.rha");

	
2007-08-23  mikio  <mikiobraun@gmail.com>

	* object.c, eval.c, list_fn.c, parse.c, prules.c: added "return
	0;" after "assert(1==0);" to make gcc happy on cygwin (otherwise
	it issued a warning that a function might return without passing a
	value)... .

2007-08-22  Stefan Harmeling  <harmeli@dhcp-153-147.inf.ed.ac.uk>

	* prelude.rha: also added function functionality to 'list', now we
	can construct a list in two ways:

	     l1 = list.new();
	     l2 = list();

	* list_fn.c (list_begin, list_done, list_next, list_get):
	introduced a new rhabarber type 'list_it_t' which is a list
	iterator.  It is used in 'prelude.rha' to define iteration for
	lists, see 'test.rha'.

	* core.c (colon_fn): added case for integers: now 

	     3:7

	becomes

	     (3, 4, 5, 6)

	* object.c (equalequal_fn): added case for strings

	* prelude.rha (fn): besides 

	     t = tuple.new(4);

	we can now also magically say

	     t = tuple(4);

	since we made t a function by adding the relevant slots.

	* prules.c (prules_init): changed priority of quote ('\') to
	10.0.  Now it is equal to all freefix forms and all assignments.
	The reason is:

	     x = \peter              x = \(peter)
	     \x = peter              \(x=peter)

	We see that most prules must be resolved simply from left to
	right.  

	* eval.c (eval_sequence, eval_args_and_call_fun), parse.c
	(resolve_code_block):   eval() no longer accepts LIST_T, which
	were used before for sequences of expression, instead a sequence
	is now a tuple with first element 'do_sym'.  This is preferable,
	since now expression in the eval function are always TUPLE_T or
	simpler.  Note that the parser generates LIST_T stuff, which is
	resolved by the prules to TUPLE_T.  Repeated resolving TUPLE_T
	doesn't change anything.

	* core.c (for_fn), prelude.rha: for-loops for tuples work, example
	code:

	      t = tuple.new(3);
	      t.set(0, 5);
	      t.set(1, 3);
	      t.set(2, 17);
	      y = 0;
	      for (x in t) y += x;
	      y == 25

2007-08-22  Mikio Braun  <mikiobraun@gmail.com>

	* gtree.h: If FAST_GTREE_LIMIT is defined, the first
	FAST_GTREE_LIMIT - 1 symbols will be stored in a field, not the
	tree. While this reduces lookups to O(1), object creation becomes
	more expensive. For moderate values of FAST_GTREE_LIMIT, for
	example, 12, runtime for fib(25) decreases to 60%.

	* rha_config.pl: symbols are now generated in the order they were
	defined.
	


