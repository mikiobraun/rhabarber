2007-08-30  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (extend): added a case for objects that implement
	'extend' themselves, like tuples.

	* prelude.rha: more fun stuff!!!  Try:

  	  l = list().push(17, 42, 66).unshift(10, 100);
	  t = tuple(l);
	  t(3) = "cool";
	  t = t + t;
	  l = list(t) + l;

	Now we have

	  l == [100, 10, 17, "cool", 66, 100, 10, 17, "cool", 66, 100, 10, 17, 42, 66]
	
	* eval.c:  rewritten the calling mechanism, which now doesn't
	distinguish between pure rhabarber functions and C-function until
	the very end of calling them.  Before the type-checking mechanism
	is the same.  note that if a builtin function is happy with
	OBJECT_T arg then no type check is triggered.  also for primitive
	types a simplified faster type check is done (object.c:pcheck()).

	* core.c (create_pattern): added
	(create_fn_data_entry): adjusted for ellipsis

	* test_run_test.rha: added a simple file which is used to test
	'run' and 'load'.

	* rha_lexer.l: added lexer support for ellipsis, i.e now should be
	able to define in rhabarber:

	f = fn (x, ...) for (y in args(1:args.len())) x+=y
	f(1,2,3,4) == 10

	* prelude.rha: the most important stuff for defining and
	overloading function has been moved out of prelude.rha to
	rha_init.c.  This makes editing prelude.rha much more robust and
	we actually need only a single file for all stuff, which I think
	is nice.  

	* overloaded.rha, tuple.rha, list.rha, testing.rha, types.rha: all
	removed and its content went to prelude.rha.

	* rhabarber.c (main): added POSIX style command line flag.  type:

	rhabarber -h    # for help
	rhabarber -t    # to run all tests in 'test.rha'
	rhabarber -d    # to avoid loading 'prelude.rha' at the beginning

	for current options (not many right now...).

	* tuple_fn.c (vtuple_make), object.c (vprint_fn), eval.c
	(vcallslot): now the policy for C-function with arbitrary argument
	lists has changed, e.g.

	object_t vcallslot(object_t obj, symbol_t slotname, tuple_t args);
	object_t callslot(object_t obj, symbol_t slotname, int_t narg, ...);

	Now the 'v-'function doesn't have 'int_t narg' anymore, since that
	information is also in 'tuple_t args'.
	
	* rha_config.d: since now 'builtin_t' is stored as 'fn_body' in
	functions, there is no need that 'builtin_t' is a struct.  From
	now on 'varag', 'signature', 'scope' is stored as slots.

	* rha_config.pl (create_init_c): added some very basic stuff to
	rha_init() like (in rhabarber-notation):

	type = new();
	type.proto = type;
	type.check = fn (x) modules.object.check(this, x);
	
	bool.check = fn (x) modules.object.pcheck(this, x);
	int.check = fn (x) modules.object.pcheck(this, x);
	...

	pattern = clone(type);
	pattern.proto = new();
	
	assign = modules.object.assign;
	extend = modules.object.extend;

	* object.c (pcheck): added a fast type check for primtypes

2007-08-29  Stefan Harmeling  <harmeling@gmail.com>

	* eval.c (signature_matches): added support for variable argument
	lists.  Consider 

	f = fn (x, ...) for (y in args(1:args.len())) x+=y
	f(1,2,3,4) == 10

	or 

	f = fn (...) { s = 0; for (y in args) s += y }
	

	* overloaded.rha: added direct access for lists, now you can do:

	l = list().push(17).push(42);
	assert(l(0) == 17);
	assert(l(1) == 42);
	l(2)   ->  error

	* object.c (check): added check(), and kept equalequal_fn() and
	notequal() since they are very basic and should not always be
	resolved via the overloaded mechanism.  removed all other simple
	functions like plus_fn and friends.  they are now organized in
	overloaded.rha 

	* prelude.rha (typename): type.check is now a builtin function
	defined in object.c.  the problem was that for overloaded function
	it is called quite a lot and if its implementation uses also
	overloaded function we are in big trouble.  in general we must be
	careful with implementing .check function, not to use any
	overloaded, since that can cause infinite loops.

	* overloaded.rha: moved code from tuple.rha and list.rha to
	overloaded.rha
	

	* rha_config.d: added all symbol which do no longer appear as
	functions in object.c to rha_config.d, e.g. plus_fn

	* core.c (run_fn): also files will generate an expression that has
	an outer do_sym, which we should ignore, since otherwise a
	'deliver' inside a file, doesn't create an error.  on the other
	hand now we also give more hints in what file and what line
	the error appeared.

2007-08-28  Stefan Harmeling  <harmeling@gmail.com>

	* overloaded.rha: put all overloaded stuff here. the reason is
	that the parser checks whether the lhs of : is a type, which is
	only possible after evaluation 'prelude.rha'.

	the less_fn relation for types is x:y.  However, this doesn't give
	right now the correct result for ptype:type which should be false.

	* eval.c (signature_matches): now the type is really checked, see
	test.rha for a simple example...

	* object.c (to_string): symbols are now shown with a backslash.

	* core.c (fn_fn, macro_fn): needed to rewrite both, since inner
	structure of function and withit macros had changed considerably.

	* eval.c (eval_rha_fun): now we look at the signature to decide on
	the function, still we only count argument, but the structure of
	how this is done allows easy extension to types and default
	arguments 

	* parse.c, prules.c: added prules for curlied and squared
	brackets, rewritten parse.c completely and got rid of many of the
	special cases.

2007-08-27  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (equalequal_fn): added cases for BOOL and REAL.

	* testing.rha: rewritten the test stuff with macros.  now the
	s-expressions of the failed tests are shown.

	* prelude.rha: defined types!  added test code for it to test.rha

	* object.c (to_string): changed the handling of primtive
	prototypes.  try e.g. 'ls(17)'

2007-08-24  Stefan Harmeling  <harmeling@gmail.com>

	* core.c (macro_fn): added a macro prule to write macro like
	functions:

	defined = macro (name) has(local, name);

	The reason for this was to avoid the overload stuff for macros,
	thus macros should be different from functions.  This might be
	changed later on.

	* bool_fn.c (bool_and), core.c: move lazy 'or' and 'and' to bool_fn.c

	* parse.c (resolve_code_block): now the semicolon after an
	expression before 'else' is optional.  however, for a code block
	it is not allowed:

	if (true) 17 else 42; next_stm;     // ok
	if (true) 17; else 42; next_stm;    // ok
	if (true) {17} else 42; next_stm;   // ok
	if (true) 17 else {42}  next_stm;   // ok
	if (true) 17 else {42};  next_stm;  // ok
	if (true) 17;; else 42; next_stm;   // wrong (like in C)
	if (true) {17}; else 42; next_stm;  // wrong (like in C)	

2007-08-24  Mikio Braun  <mikiobraun@gmail.com>

	* parse.c (resolve_list_by_head): changed ordering of the checks
	to make it "more logical" (First if used to check for a large
	negated condition). Hopefully still correct ;)

	* parse.c: cleaned up and rearranged this file a bit

2007-08-24  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (extend): wrote function 'extend' which is able to add
	new cases to function, or to create new functions.

	* eval.c (call_rha_fun): uses the new representation of functions
	and is able to find the implementation of the first function that
	has the same number of arguments.

	* core.c (fn_fn, create_fn_data, create_fn_data_entry): the inner
	representation of function has changed. now all information is
	stored in a slot 'fn_data' which must contain a list of 3-tuples,
	each of which has entries 'argnames', 'env', and 'fnbody'.

	* prules.c (resolve_assign_prule): now assignments to symbols
	still creates assignment, but assignments to calls creates
	extends:

	    x=0          (assign local x 0)
	    a.x=0        (assign a x 0)

	    f(x)=0       (extend local (quote f) (quote (x)) local (quote 0))
	    a.f(x)=0     (extend a     (quote f) (quote (x)) local (quote 0))

	* eval.c (call_rha_fun): added 'static'

	* parse.c (resolve_code_block): now a sequence of commands in
	curly brackets is split after a code block (in curly brackets) if
	not a "second-order-keyword" such as currently 'else' or 'catch'
	is following.  However, this solution is preliminary, since if we
	extend the syntax with new complicated freefix form we need to add
	them here by hand.

	* rha_lexer.l: removed the case with \n  \n that generated a
	semicolon, since now 'resolve_code_block' deals with it.

	* rhabarber.c (main): the outer-most (do_sym 17; 42+42) is now
	dealt with outside the eval function, which makes sense, since it
	only happens in the real-eval-loop.  now typing 'deliver 17' at
	the prompt generates (do_sym (deliver 17)) but doesn't open a
	BLOCK_FRAME and thus issues the correct error.

2007-08-23  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (extend): added extend, which is not done yet and which
	doesn't really extend right now, but should only overwrite an
	existing function definiton.

	* prules.c (resolve_assign_prule): rewritten the whole thing for
	stuff like f(x)=2*x.  However, right now += and friends no longer
	work.  But can be easily put back.

	* tuple_fn.c (tuple_set): now also tuple_set returns the tuple and
	we can do:

	    t = tuple(3).set(0, 17).set(1, 42).set(2, 55);

	* list.rha (fn): added PERL like pop, push, shift, unshift.

	* parse.c (resolve_dots_and_fn_calls): rewrote the whole thing to
	allow magic stuff like:

	     l = list().push(17).push(42);

	* list_fn.c (list_append, list_prepend, list_extend): all of them
	return now the list.

2007-08-23  Mikio Braun  <mikiobraun@gmail.com>

	* object.c (assign): added error message if you try to assign a
	void

2007-08-23  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (to_string): catch the case for 'symbol.proto' which is
	a symbol but has value zero.

	* symbol_fn.c (symbol_name): check for accessing symbol number
	zero.
	

	* rhabarber.c (main): fixed a bug that happens when just pressing
	return at the prompt, now the parse() function might return zero
	which is fine with eval() and fprint("%o").

2007-08-23  Stefan Harmeling  <harmeli@dhcp-153-147.inf.ed.ac.uk>

	* eval.c, rhabarber.c, prules.c, rha_config.pl, object.c, core.c,
	parse.c, eval.c: removed 'void_obj', now 0 is void_obj.  note that
	there is still symbol 'void' which could be internally represented
	by: 
	    object_t void_obj = 0;

	(eval): lookup for void now works...

	* prelude.rha: added for convenience

	    runtest = fn () run(root, "test.rha");

	
2007-08-23  mikio  <mikiobraun@gmail.com>

	* object.c, eval.c, list_fn.c, parse.c, prules.c: added "return
	0;" after "assert(1==0);" to make gcc happy on cygwin (otherwise
	it issued a warning that a function might return without passing a
	value)... .

2007-08-22  Stefan Harmeling  <harmeli@dhcp-153-147.inf.ed.ac.uk>

	* prelude.rha: also added function functionality to 'list', now we
	can construct a list in two ways:

	     l1 = list.new();
	     l2 = list();

	* list_fn.c (list_begin, list_done, list_next, list_get):
	introduced a new rhabarber type 'list_it_t' which is a list
	iterator.  It is used in 'prelude.rha' to define iteration for
	lists, see 'test.rha'.

	* core.c (colon_fn): added case for integers: now 

	     3:7

	becomes

	     (3, 4, 5, 6)

	* object.c (equalequal_fn): added case for strings

	* prelude.rha (fn): besides 

	     t = tuple.new(4);

	we can now also magically say

	     t = tuple(4);

	since we made t a function by adding the relevant slots.

	* prules.c (prules_init): changed priority of quote ('\') to
	10.0.  Now it is equal to all freefix forms and all assignments.
	The reason is:

	     x = \peter              x = \(peter)
	     \x = peter              \(x=peter)

	We see that most prules must be resolved simply from left to
	right.  

	* eval.c (eval_sequence, eval_args_and_call_fun), parse.c
	(resolve_code_block):   eval() no longer accepts LIST_T, which
	were used before for sequences of expression, instead a sequence
	is now a tuple with first element 'do_sym'.  This is preferable,
	since now expression in the eval function are always TUPLE_T or
	simpler.  Note that the parser generates LIST_T stuff, which is
	resolved by the prules to TUPLE_T.  Repeated resolving TUPLE_T
	doesn't change anything.

	* core.c (for_fn), prelude.rha: for-loops for tuples work, example
	code:

	      t = tuple.new(3);
	      t.set(0, 5);
	      t.set(1, 3);
	      t.set(2, 17);
	      y = 0;
	      for (x in t) y += x;
	      y == 25

2007-08-22  Mikio Braun  <mikiobraun@gmail.com>

	* gtree.h: If FAST_GTREE_LIMIT is defined, the first
	FAST_GTREE_LIMIT - 1 symbols will be stored in a field, not the
	tree. While this reduces lookups to O(1), object creation becomes
	more expensive. For moderate values of FAST_GTREE_LIMIT, for
	example, 12, runtime for fib(25) decreases to 60%.

	* rha_config.pl: symbols are now generated in the order they were
	defined.
	


