2009-01-14  Stefan Harmeling  <harmeling@gmail.com>

	* eval.c (call_ccode_fun): ok, issue solved.  introduced a new
	basic type called 'ccode_t' (see rha_config.d).  For now the
	signature is fixed.  Maybe we can use 

	* example.c (wrapped_ccode): try the following to see the current
	issue:
	modules.ccode.ccode("result=f(arg1);", int, int)(17)
	somehow the generate object does not have a valid symbol table

2009-01-11  Stefan Harmeling  <harmeling@gmail.com>

	* Makefile.am (AM_CFLAGS): added -fno-common which seems to be
	important for the -dynamiclib business of macos.  see ccode.c

2007-11-06  Stefan Harmeling  <harmeling@gmail.com>

	* eval.c (pattern_lessthan): to define the lessthan relation for
	patterns we need to check for subtyping, thus we need to call
	'isparent' and NOT 'check'.

	* object.c (isparent, check): now we distinguish between:
	(i) is 'x' an instance of 't', which is 'check(t, x)'
	(ii) is 'x' a subtype of 't', which is 'isparent(t, x)'

	* prelude.rha: removed new(type:t) which was for creating
	instances.  however it was mostly used for new(type) which is
	better done by clone(type) with the same effect.

	E.g.  a new slice instance is created (inside the constructor) by
	s = clone(slice.proto);

	Right now we have structural subtying with additional nominal
	subtyping.  If 't' is an ancestor of 'x', then 'x' is a subtype of
	't'.  This is checked by 'type.isparent' which is available in all
	subtypes of 'type'.

	Note that objects like 'iterable' which are like JAVA interfaces
	can implement their own 'isparent' function which might check for
	the existence of certain slots.
	
	To check whether 'x' is an instance of a type 't', we call
	't.check(x)' which can be written as 't:x' 

	    int:17           // TRUE
	    tuple:[1,2,3]    // TRUE
	    iterable:tuple   // FALSE, since 'tuple' is not a tuple but a type
	    iterable:[1,2,3] // TRUE
	    iterable.isparent(tuple)  // TRUE
	
2007-11-05  Stefan Harmeling  <harmeling@gmail.com>

	* Right now the automated embedding with 
	     //#include "gsl_matrix_double.h"
	in rha_config.d is NOT working.  To get a feel for the current
	issue uncomment	that line and run 'make clean; make'.

	The problem is that some return values are not pointer and we need
	more sophisticated code than just taking the address with '&' to
	deal with it correctly.  Mikio, do you have some idea?
	
	* AGAIN: there was a problem with automatically generated
	macroconstant "_SIZE_T" after binding in some GSL stuff.  Thus the
	naming scheme changed again.  Now the type name stays the same and
	only "RHA_" is prepended.  E.g.:

	int             RHA_int
	PyObject_ptr    RHA_PyObject_ptr
	
	* rha_config.pl: Note that the _rha_ is now ignored.  All
	functions of a header listed in rha_config.d will be loaded.
	Functions that should not be loaded can be excluded by the keyword
	_ignore_. 
	(process_module): now newlines gets replaced by space and is not
	removed any longer.

	Note that the types appearing in functions that are embedded are
	automatically introduced to rhabarber.  The types listed in
	rha_config.d are only there for convenient inclusion in
	rhabarber's sources.

	* object.h: removed some unused functions.

	* symbol_fn.h: commented out three wraping functions, which were
	not find at linking time.  Did anybody use them?

	* python_fn.h: non-rhabarber stuff written in C that is included
	at compile time doesn't need to use special rhabarber types.  Just
	use the usual types, like PyObject * and rha_config.pl will
	automatically create the necessary types, which will appear in
	'root.types'.

	Note that to check ptypes you need to find out how your type
	translates to the macroconstant.  For PyObject * this becomes:

	  _PYOBJECT_PTR

	Maybe we should also allow lower case letter, to avoid possible
	conflicts.
	

2007-11-02  Stefan Harmeling  <harmeling@gmail.com>

	* ALLOVERTHEPLACE: naming scheme for types has changed, since now
	types are automatically included from all modules.  Don't use
	'int_t' and 'bool_t' anymore, use instead 'int' and 'bool'.  All
	types that we declare additionally in C end with '_t' as before.
	The macro-constants do now start with '_', the rest is exactly the
	name of the type, e.g. '_INT', '_TUPLE_T'.

	   in C                           in rhabarber
	   typename   macroconstant       typename
	     int        _INT                 int
	     bool       _BOOL                bool
	     real_t     _REAL_T              real_t
	     string_t   _STRING_T            string_t
	     tuple_t    _TUPLE_T             tuple_t

	Note that 'real_t' and 'string_t' gets renamed in 'prelude.rha'...

	All types are now under 'root.types'.  In 'prelude.rha' only those
	are used that are needed.
	
	* prelude.rha (mat.proto(..., ...)): added slice support for
	matrices:

	m = randn(10,12);
	m(:);
	m(:,:);
	m(:-1, 10);
	m(10:-1:, :2:);
	m(:3:)

	* core.c (create_pattern): simplified the calling signature, which
	used to have arbitrary many arguments, which was unnecessary.  Now
	it takes two: 'theliteral' and 'thetype'.

	* prules.c (resolve_freefix_prule2): changed assertion to check,
	since with 'f(x) if 17' it can happen that the next prule to apply
	is 'if' but it is not the first in the parsetree.
	(colon_pr): changed the output of 'colon_pr', the easiest to learn
	about it is to type:

	\:
	\:42
	\10:
	\10:42

	at the prompt.

	* prelude.rha (iterable.check): simplified the check to only look
	for 'iter' slot, since for slices we can only call 'iter' if we
	provide a bound.

	(tuple.proto.extend): now lists and slices are allowed to
	manipulate tuples:

	t = tuple(10);
	t(list[1,2,3,4]) = 17;
	t(0:2:) = 42;
	t(6:-2:) = 77;        // puts automatically -1 as lower bound
	t
	(77 17 77 17 77 <void> 77 <void> 42 <void>)

2007-10-31  Stefan Harmeling  <harmeling@gmail.com>

	* prelude.rha: now we can do stuff like:

	t = tuple(10);
	t(0:5) = 17;
	t(6:10) = 6:10;

	Almost, some little bugs remain.

	* core.c (for_fn): minor adjustments to allow

	for ([x,y] in zip(0:5, 5:10))
	   print(x+y);

	* prules.c (resolve_assign_prule): now also multiple values can be
	assigned:

	// MOST BASIC ASSIGNMENTS:
	// x = 0            (assign_fn local \x 0)
	// a.x = 0          (assign_fn a     \x 0)
	// a(z).x = 0       (assign_fn (a z) \x 0)

	// ASSIGNMENTS THAT OVERLOAD FUNCTIONS:
	// f(x) = 0         (extend local \f \(x) local 0)
	// a.f(x) = 0       (extend a     \f \(x) local 0)
	// a(z).f(x) = 0    (extend (a z) \f \(x) local 0)

	// ASSIGNMENTS WITH LIST LITERALS ON THE LHS:
	// [x, y] = alist       (assign_fn local (\x \y) alist)
	// a.[x, y] = alist     (assign_fn a     (\x \y) alist)
	// a(z).[x, y] = alist  (assign_fn (a z) (\x \y) alist)
	// only flat lists of symbols are allowed on LHS and the RHS must be iterable


	* object.[ch]: added 'assign_fn' which calls:

	    assign         for symbols, e.g. x = 17
	    assign_many    for tuples of symbols, e.g. [x, y] = [17, 42]

	* prelude.rha: added 'zip'

	rha[0](-1)$ zip(0:5, 5:10)
        [(0 5), (1 6), (2 7), (3 8), (4 9)]


	* test.rha: added more test code for slices.

	* prelude.rha: improved implementation of slices.  Since slices
	are iterable, everything should be done via iterators.  Examples
	include list(slice:s) and list(slice:s, int:len).  Now all
	variations of positive and negative indices should work.

2007-10-30  Stefan Harmeling  <harmeling@gmail.com>

	* prelude.rha: added a new datatype for 'slice', which is used to
	access several elements of tuples and list and other stuff...

	* object.c (unwrap_ptr, unwrap_builtin): added checks whether the
	raw pointer contains something non-zero.  This is necessary since
	the raw pointer of prototype object is zero and thus stuff like
	the following breaks:

	  string.proto + "test"    // bus error
	  tuple.proto.get(0)       // bus error

	* list_fn.h: added list_chop(), which chops a list into pieces at
	the location of a certain symbol.

	* prules.c (colon_pr): added better colon support.  All of the
	following do now work, alongside with stuff like "int:17"...

	  // (i) without step size
          //       :               == 0:1:     (slice without bounds)
	  //       :42             == 0:1:42   (slice with upper bound)
	  //       17:             == 17:1:    (slice with lower bound)
	  //       17:42           == 17:1:42  (slice with bounds)
	  // (ii) with step size
	  //       :2:             == 0:2:     (slice without bounds but with step)
	  //       :2:10           == 0:2:10   (slice with upper bound and step)
	  //       17:2:           == 17:2:    (slice with lower bound and step)
	  //       17:2:42         == 17:2:42  (slice with bounds and step) 

	Also negative numbers are accepted for slices:

	   t = tuple(5);
	   t(2:-2);

	And negative step sizes

	   t(-1:-1:0);

	Looks like this doesn't work yet :(
	
	Also the colon can be used in loops like this:

	  for (i in 17:42) print(i);
	  for (i in 17:2:42) print(i);
	  for (i in 17:-1:0) print(i);

	

2007-10-29  Stefan Harmeling  <harmeling@gmail.com>

	* Makefile.am: added 

	      rhabarber_LDFLAGS = -framework Python

	which is for MacOS.  Does it still work for UNIX?

2007-10-10  Stefan Harmeling  <harmeling@gmail.com>

	* configure.ac: changed -lm check from "sinx" to "pow"
	

2007-09-18  Mikio Braun  <mikiobraun@gmail.com>

	* domains.rha: set up the domains framework. With
	obj.convert(domain), the object is converted into the
	corresponding object in domain. convert_call converts a call such
	that the arguments are aligned with the domain. 

	* python.rha: brought things into alignment with domains.rha. 

	* rha_parser_fcts.h: had to move rha_parser.h out of the way
	because the automake rules made bison directly output a file
	called rha_parser.h

2007-09-04  Stefan Harmeling  <harmeling@gmail.com>

	* parse.c (resolve_dots_and_fn_calls): added a case for resolving
	complex literals, note that the syntax of rhabarber has changed:

	before:  list:[1,2,3]    // bad: looks like type check
	now:     list[1,2,3]     // like a funcall

	added test code in test.rha
	
	* prules.c (colon_pr): removed the stuff that transformed
	tuple:[1,2,3] into tuple.literal([1,2,3]).  instead this is now
	handled in resolve_dots_and_fn_calls.

	* object.c (to_string): however, we still cannot guarantee that
	builtin function always receive 0 instead of void_obj.  The latter
	happens when called via eval(), but when called from other C-code
	the void_obj might reach a builtin function.  There might be other
	places where we need to extend the zero case with void_obj similar
	to to_string().

	* eval.c (call_builtin_fun): void_obj as arguments to builtin
	functions are replaced by zeros.

	* object.c (assign): if trying to assign 0, we assign void_obj.

	* rha_config.pl: now an object void_obj is generated in
	rha_init().  Builtin function with return value void return now
	void_obj. 

	* mat_fn.c, utils.c: added bound checks for matrix get/set via
	idx() function defined in utils.c which allows negative indices.

	* prules.c (resolve_assign_prule): commented out the
	'lookup-local' stuff, problem was something like:

	f = fn (x) 2*x;
	g = new();
	g.fn_data = list();
	g.fn_data.push(clone(f.fn_data(0)));
	

	* python.c (start_python_if_necessary): added some functions for demo...

	* python.h: added more functions

	* core.c (vcreate_pattern): introduced patternliteral_sym,
	patterntype_sym
	

	* eval.c (pattern_matches): removed serious bug.  the problem was
	that after not finding but trying to find, variable 'impl' had a
	non-zero value and was thus chosen.  the problem was that:

	if (17) 42

	was allowed but would fail with an assert.

	added support for sorting implementations.  Now the list of
	implementations f.fn_data is sorted such that for i<j we never
	have signature(i)>signature(j).
	
2007-09-03  Stefan Harmeling  <harmeling@gmail.com>

	* utils.c (idx): added function that checks index bounds and deals
	with negative indices.  This function is currently used in
	tuple_fn.c and mat_fn.c.

	* list_fn.c (list_insert_sorted): added function that can insert
	in a way that keeps the list sorted.  More precisely for non-total
	orderings we say a list l = [l(0), l(1), ..., l(100)] is sorted if
	there are no indices i < j such that l(j) < l(i).

	* eval.c (pattern_lessthan, signature_lessthan)
	(fn_data_entry_lessthan): added these comparison function to
	compare fn_data entries in object.c::extend().  Now entering:

	f(n) = n*f(n-1);  f(1) = 1;

	Should be fine and lead to the same overloaded function as
	
	f(1) = 1; f(n) = n*f(n-1);

	does.
	
	* object.c (is_void): added a function to check for void-ness.

	* prules.c (split_by_semicolon): merged two splitting cases into
	one.  however, I omitted the inclusion of splitting be equal_sym
	for the following problem;  the idea was that

	    x = y = 1           becomes    x = 1; y = x
	    f(1) = f(2) = 1     becomes    f(1) = 1; f(2) = f(1)

	However, what about:   f(int:x) = f(real:x) = 2*x
	That would be nice as well.  However, the correct translation
	would be:

	                   f(int:x) = 2*x; f(real:x) = 2*x

	since in this case the RHS is not evaluated.  However, at the time
	of 'split_by_semicolon' we can't know that.  Thus we keep it as it
	is.

2007-09-03  Mikio Braun  <mikiobraun@gmail.com>

	* python.c, python.rha: Basic python support is in there:
	Generating integers, floats, loading modules, calling functions,
	printing python objects. Whole auto-conversion stuff is not yet in
	there.

	* rhabarber.c (main): Now also accepts an additional filename
	which is then run.

	* eval.c: restructured source code to make it less a waterfall of
	function calls. Now, everything is contained in call_fun, with
	more helper functions.

2007-09-02  Stefan Harmeling  <harmeling@gmail.com>

	* eval.c (pattern_matches), object.c (extend): removed bug that
	prevented the literal mechanism to work: now we can do the
	following cool stuff:

	f(1) = 1;
	f(2) = 1;
	f(n) = f(n-1) + f(n-2);

	Return value is void for 'f(x) = 2*x'.  The problem is when typing

	f(1) = f(2) = 17;

	we really get:

	f(2) = 17;
	f(1) = (f(2) = 17);

	since the RHS is *not* evaluated for this syntactic sugar.

	* prelude.rha: added support for matrix access:

	m = rand(4,3);
	m(2,3) = 0;
	m(1,2);

	added macros for lazy 'and' and 'or', which now work the next line
	of 'prelude.rha'.
	
	* parse.c: removed 'parse()' and 'parse_file()' which are now
	obsolete since the introduction of 'split_resolve_and_eval'.
	
	* Makefile (test): added case that allows a clean built and
	running of the test cases in test.rha by typing 'make test'.

	* core.c (split_resolve_and_eval): new function that splits a
	bison-parsed string into semicolon separated expression, which are
	evaluated immediately after resolving prules.  The advantage is
	that macros defined in some file (e.g. lazy 'and_fn') can be used
	a few lines later already (e.g. in 'colon_fn').
	(run_fn), rhabarber.c: now the main read-eval-print loop and
	'run_fn' are using the 'split_resolve_and_eval' function.  this
	also removed some of the uglyness of having a loop in 'main'.

	* prules.c (curlied_pr): separated a new function
	'split_by_semicolon' which is also used in
	'split_resolve_and_eval' in core.c

2007-09-01  Stefan Harmeling  <harmeling@gmail.com>

	* Changed all "object_t" to "any_t" which is a better description
	what 'object_t' is inside rhabarber if you ask for type
	information.  I guess this is controversial and you might not
	agree with me that that was a good idea.  Anyhow, I am happy to
	revert it!
	
	* rha_lexer.l (escexpand): now 'escexpand' only expands but
	doesn't copy, i.e. the string is expanded in place and will be
	shorter accordingly.
	(\"): instead of ALLOW_RAW in escexpand, we now use gc_strup()
	from alloc.h.
	(\"\"): to avoid conflicts with matrix transpose (which is a'), we
	now use double "" for string that are not expanded.  Note that the
	rule for the double quotes must come before the rule for the
	single quotes, to deal correctly with the empty string.
	(...): sorted the operators according to their length to make
	explicit which operators exist and which not.

	* prules.c (try_pr): removed bug, which ignored one level of
	list-lists...  the solution is a dirty hack as well and doesn't
	make the code nicer, but it looks like it works! 
	(see for instance prelude.rha:literal)

	* prelude.rha: now support for complex literals:

	[1,2,3]                // matrix
	[1,"et",3]             // list
	[1,3,6;31.14, 4.5, 5]  // matrix
	mat:[1,2,3]            // force matrix
	mat:[1,2,"test"]       // error
	tuple:[1,2,3]          // force tuple
	[,1,3]                 // error
	[1,,3]                 // error
	
	* prelude.rha, mat_fn.[hc], prules.[hc], rha_lexer.l, real_fn.[hc]: 
	added matrix support, including transpose, Hadamard product, etc.
	E.g. 

	a = randn(3,4);
	b = randn(4,5);
	c = a*(b.*b)*2;
	d = 3.14*a*(b.*b)*2.0/1;
	e = a*a';
	
2007-08-31  Stefan Harmeling  <harmeling@gmail.com>

	* prelude.rha (fn): removed bug in split_parselist, try:

   split_parselist(list().push(symbol(";"),symbol(",")),local,eval((\[1,2;3])(2)))
	
	as a note: (\[1,2;3])(2) is a cool way of generating  (\ [1, ,, 2, ;, 3])
	which becomes [1, ,, 2, ;, 3] after applying eval...
	
	* core.c (while_fn): added check whether the condition returns BOOL_T.

	* prules.c, prelude.rha: now complex literal start to work.  For
	this colon_pr() and squared_pr() had to adjusted.  Now we can
	implement complex literal behavior inside rhabarber.  See for
	instance in prelude.rha

	tuple.literal
	list.literal
	literal
	split_parselist

	However, some works needs to be done to make it convenient.

	* prelude.rha: now everything looks great!

	rha[0](-1)$ new.fn_data
	0 builtin()
	1 function(type:t)
	rha[1](-1)$ new.fn_data(1)
	function(type:t)
	rha[2](-1)$ callslot.fn_data
	0 builtin(object:<nosym>, symbol:<nosym>, ...)
	rha[3](-1)$ 

	* object.c: 'to_string' is now calling slot 'string' if possible.
	For internal use there is the much more robust version
	'to_string_only_in_c'.  The name is long, but right now it is only
	used for the implementation of utils.c:sprint()

	* core.c, parse.c: the problem:  consider

	    f(int:x, real:y) = 17

	previously 'int' was evaluated in parse.c and a check was done
	whether a slot 'check' exists.  This has now changed.  Instead
	parse.c creates for such a signature:

           (map_fn local pattern (\ (((\ x) int) ((\ y) real))))

	which is evaluated later when the whole expression is evaluated.
	Of course this required lots of changes all over the place.

	* tuple_fn.h: made vtuple_make accessible inside rhabarber

	* prules.c (resolve_assign_prule): the signature is now no longer
	quoted, since it is an expression that needs to be evaluated to
	generate a signature, which is a list of patterns.

	* object.c (create_function): renamed it to create_builtin to
	avoid name conflict with new 'create_function' in core.c

	* object.c (to_string): removed \" from strings...

2007-08-31  Mikio Braun  <mikiobraun@gmail.com>

	* eval.c (call_fun, call_matching_impl): construct of
	FUNCTION_FRAME now depends on whether fn_data.no_frame exists or
	not. This should allow to 'break' or 'return' from 'if'
	expressions.

	* core.c (deliver_fn, return_fn, throw_fn, break_fn): removed
	'frame_tos--'. This is now handled by defining 'fn_data.no_frame'

	* eval.c, eval.h: cleaned up both files. Removed obsolete
	functions, declared all internal functions as "static", reordered
	functions to match top-down call order.

2007-08-30  Mikio Braun  <mikiobraun@gmail.com>

	* eval.h (frame_jump): Quick fix for the 'break' and 'deliver'
	issue. The problem was that break does not work anymore since
	'for' itself is a function and 'break' does not cross function
	boundaries.

	The fix is: it crosses boundaries. This means that a function
	which does not contain a 'for' loop might nevertheless call
	'break' in order to break an outer for loop (and the same also for
	'deliver') I guess there is no cleaner solution.

	* eval.c, eval.h: removed code for location tracking (unused as of
	now, we can put it back in later.

2007-08-30  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (extend): added a case for objects that implement
	'extend' themselves, like tuples.

	* prelude.rha: more fun stuff!!!  Try:

  	  l = list().push(17, 42, 66).unshift(10, 100);
	  t = tuple(l);
	  t(3) = "cool";
	  t = t + t;
	  l = list(t) + l;

	Now we have

	  l == [100, 10, 17, "cool", 66, 100, 10, 17, "cool", 66, 100, 10, 17, 42, 66]
	
	* eval.c:  rewritten the calling mechanism, which now doesn't
	distinguish between pure rhabarber functions and C-function until
	the very end of calling them.  Before the type-checking mechanism
	is the same.  note that if a builtin function is happy with
	OBJECT_T arg then no type check is triggered.  also for primitive
	types a simplified faster type check is done (object.c:pcheck()).

	* core.c (create_pattern): added
	(create_fn_data_entry): adjusted for ellipsis

	* test_run_test.rha: added a simple file which is used to test
	'run' and 'load'.

	* rha_lexer.l: added lexer support for ellipsis, i.e now should be
	able to define in rhabarber:

	f = fn (x, ...) for (y in args(1:args.len())) x+=y
	f(1,2,3,4) == 10

	* prelude.rha: the most important stuff for defining and
	overloading function has been moved out of prelude.rha to
	rha_init.c.  This makes editing prelude.rha much more robust and
	we actually need only a single file for all stuff, which I think
	is nice.  

	* overloaded.rha, tuple.rha, list.rha, testing.rha, types.rha: all
	removed and its content went to prelude.rha.

	* rhabarber.c (main): added POSIX style command line flag.  type:

	rhabarber -h    # for help
	rhabarber -t    # to run all tests in 'test.rha'
	rhabarber -d    # to avoid loading 'prelude.rha' at the beginning

	for current options (not many right now...).

	* tuple_fn.c (vtuple_make), object.c (vprint_fn), eval.c
	(vcallslot): now the policy for C-function with arbitrary argument
	lists has changed, e.g.

	object_t vcallslot(object_t obj, symbol_t slotname, tuple_t args);
	object_t callslot(object_t obj, symbol_t slotname, int_t narg, ...);

	Now the 'v-'function doesn't have 'int_t narg' anymore, since that
	information is also in 'tuple_t args'.
	
	* rha_config.d: since now 'builtin_t' is stored as 'fn_body' in
	functions, there is no need that 'builtin_t' is a struct.  From
	now on 'varag', 'signature', 'scope' is stored as slots.

	* rha_config.pl (create_init_c): added some very basic stuff to
	rha_init() like (in rhabarber-notation):

	type = new();
	type.proto = type;
	type.check = fn (x) modules.object.check(this, x);
	
	bool.check = fn (x) modules.object.pcheck(this, x);
	int.check = fn (x) modules.object.pcheck(this, x);
	...

	pattern = clone(type);
	pattern.proto = new();
	
	assign = modules.object.assign;
	extend = modules.object.extend;

	* object.c (pcheck): added a fast type check for primtypes

2007-08-29  Stefan Harmeling  <harmeling@gmail.com>

	* eval.c (signature_matches): added support for variable argument
	lists.  Consider 

	f = fn (x, ...) for (y in args(1:args.len())) x+=y
	f(1,2,3,4) == 10

	or 

	f = fn (...) { s = 0; for (y in args) s += y }
	

	* overloaded.rha: added direct access for lists, now you can do:

	l = list().push(17).push(42);
	assert(l(0) == 17);
	assert(l(1) == 42);
	l(2)   ->  error

	* object.c (check): added check(), and kept equalequal_fn() and
	notequal() since they are very basic and should not always be
	resolved via the overloaded mechanism.  removed all other simple
	functions like plus_fn and friends.  they are now organized in
	overloaded.rha 

	* prelude.rha (typename): type.check is now a builtin function
	defined in object.c.  the problem was that for overloaded function
	it is called quite a lot and if its implementation uses also
	overloaded function we are in big trouble.  in general we must be
	careful with implementing .check function, not to use any
	overloaded, since that can cause infinite loops.

	* overloaded.rha: moved code from tuple.rha and list.rha to
	overloaded.rha
	

	* rha_config.d: added all symbol which do no longer appear as
	functions in object.c to rha_config.d, e.g. plus_fn

	* core.c (run_fn): also files will generate an expression that has
	an outer do_sym, which we should ignore, since otherwise a
	'deliver' inside a file, doesn't create an error.  on the other
	hand now we also give more hints in what file and what line
	the error appeared.

2007-08-28  Stefan Harmeling  <harmeling@gmail.com>

	* overloaded.rha: put all overloaded stuff here. the reason is
	that the parser checks whether the lhs of : is a type, which is
	only possible after evaluation 'prelude.rha'.

	the less_fn relation for types is x:y.  However, this doesn't give
	right now the correct result for ptype:type which should be false.

	* eval.c (signature_matches): now the type is really checked, see
	test.rha for a simple example...

	* object.c (to_string): symbols are now shown with a backslash.

	* core.c (fn_fn, macro_fn): needed to rewrite both, since inner
	structure of function and withit macros had changed considerably.

	* eval.c (eval_rha_fun): now we look at the signature to decide on
	the function, still we only count argument, but the structure of
	how this is done allows easy extension to types and default
	arguments 

	* parse.c, prules.c: added prules for curlied and squared
	brackets, rewritten parse.c completely and got rid of many of the
	special cases.

2007-08-27  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (equalequal_fn): added cases for BOOL and REAL.

	* testing.rha: rewritten the test stuff with macros.  now the
	s-expressions of the failed tests are shown.

	* prelude.rha: defined types!  added test code for it to test.rha

	* object.c (to_string): changed the handling of primtive
	prototypes.  try e.g. 'ls(17)'

2007-08-24  Stefan Harmeling  <harmeling@gmail.com>

	* core.c (macro_fn): added a macro prule to write macro like
	functions:

	defined = macro (name) has(local, name);

	The reason for this was to avoid the overload stuff for macros,
	thus macros should be different from functions.  This might be
	changed later on.

	* bool_fn.c (bool_and), core.c: move lazy 'or' and 'and' to bool_fn.c

	* parse.c (resolve_code_block): now the semicolon after an
	expression before 'else' is optional.  however, for a code block
	it is not allowed:

	if (true) 17 else 42; next_stm;     // ok
	if (true) 17; else 42; next_stm;    // ok
	if (true) {17} else 42; next_stm;   // ok
	if (true) 17 else {42}  next_stm;   // ok
	if (true) 17 else {42};  next_stm;  // ok
	if (true) 17;; else 42; next_stm;   // wrong (like in C)
	if (true) {17}; else 42; next_stm;  // wrong (like in C)	

2007-08-24  Mikio Braun  <mikiobraun@gmail.com>

	* parse.c (resolve_list_by_head): changed ordering of the checks
	to make it "more logical" (First if used to check for a large
	negated condition). Hopefully still correct ;)

	* parse.c: cleaned up and rearranged this file a bit

2007-08-24  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (extend): wrote function 'extend' which is able to add
	new cases to function, or to create new functions.

	* eval.c (call_rha_fun): uses the new representation of functions
	and is able to find the implementation of the first function that
	has the same number of arguments.

	* core.c (fn_fn, create_fn_data, create_fn_data_entry): the inner
	representation of function has changed. now all information is
	stored in a slot 'fn_data' which must contain a list of 3-tuples,
	each of which has entries 'argnames', 'env', and 'fnbody'.

	* prules.c (resolve_assign_prule): now assignments to symbols
	still creates assignment, but assignments to calls creates
	extends:

	    x=0          (assign local x 0)
	    a.x=0        (assign a x 0)

	    f(x)=0       (extend local (quote f) (quote (x)) local (quote 0))
	    a.f(x)=0     (extend a     (quote f) (quote (x)) local (quote 0))

	* eval.c (call_rha_fun): added 'static'

	* parse.c (resolve_code_block): now a sequence of commands in
	curly brackets is split after a code block (in curly brackets) if
	not a "second-order-keyword" such as currently 'else' or 'catch'
	is following.  However, this solution is preliminary, since if we
	extend the syntax with new complicated freefix form we need to add
	them here by hand.

	* rha_lexer.l: removed the case with \n  \n that generated a
	semicolon, since now 'resolve_code_block' deals with it.

	* rhabarber.c (main): the outer-most (do_sym 17; 42+42) is now
	dealt with outside the eval function, which makes sense, since it
	only happens in the real-eval-loop.  now typing 'deliver 17' at
	the prompt generates (do_sym (deliver 17)) but doesn't open a
	BLOCK_FRAME and thus issues the correct error.

2007-08-23  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (extend): added extend, which is not done yet and which
	doesn't really extend right now, but should only overwrite an
	existing function definiton.

	* prules.c (resolve_assign_prule): rewritten the whole thing for
	stuff like f(x)=2*x.  However, right now += and friends no longer
	work.  But can be easily put back.

	* tuple_fn.c (tuple_set): now also tuple_set returns the tuple and
	we can do:

	    t = tuple(3).set(0, 17).set(1, 42).set(2, 55);

	* list.rha (fn): added PERL like pop, push, shift, unshift.

	* parse.c (resolve_dots_and_fn_calls): rewrote the whole thing to
	allow magic stuff like:

	     l = list().push(17).push(42);

	* list_fn.c (list_append, list_prepend, list_extend): all of them
	return now the list.

2007-08-23  Mikio Braun  <mikiobraun@gmail.com>

	* object.c (assign): added error message if you try to assign a
	void

2007-08-23  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (to_string): catch the case for 'symbol.proto' which is
	a symbol but has value zero.

	* symbol_fn.c (symbol_name): check for accessing symbol number
	zero.
	

	* rhabarber.c (main): fixed a bug that happens when just pressing
	return at the prompt, now the parse() function might return zero
	which is fine with eval() and fprint("%o").

2007-08-23  Stefan Harmeling  <harmeli@dhcp-153-147.inf.ed.ac.uk>

	* eval.c, rhabarber.c, prules.c, rha_config.pl, object.c, core.c,
	parse.c, eval.c: removed 'void_obj', now 0 is void_obj.  note that
	there is still symbol 'void' which could be internally represented
	by: 
	    object_t void_obj = 0;

	(eval): lookup for void now works...

	* prelude.rha: added for convenience

	    runtest = fn () run(root, "test.rha");

	
2007-08-23  mikio  <mikiobraun@gmail.com>

	* object.c, eval.c, list_fn.c, parse.c, prules.c: added "return
	0;" after "assert(1==0);" to make gcc happy on cygwin (otherwise
	it issued a warning that a function might return without passing a
	value)... .

2007-08-22  Stefan Harmeling  <harmeli@dhcp-153-147.inf.ed.ac.uk>

	* prelude.rha: also added function functionality to 'list', now we
	can construct a list in two ways:

	     l1 = list.new();
	     l2 = list();

	* list_fn.c (list_begin, list_done, list_next, list_get):
	introduced a new rhabarber type 'list_it_t' which is a list
	iterator.  It is used in 'prelude.rha' to define iteration for
	lists, see 'test.rha'.

	* core.c (colon_fn): added case for integers: now 

	     3:7

	becomes

	     (3, 4, 5, 6)

	* object.c (equalequal_fn): added case for strings

	* prelude.rha (fn): besides 

	     t = tuple.new(4);

	we can now also magically say

	     t = tuple(4);

	since we made t a function by adding the relevant slots.

	* prules.c (prules_init): changed priority of quote ('\') to
	10.0.  Now it is equal to all freefix forms and all assignments.
	The reason is:

	     x = \peter              x = \(peter)
	     \x = peter              \(x=peter)

	We see that most prules must be resolved simply from left to
	right.  

	* eval.c (eval_sequence, eval_args_and_call_fun), parse.c
	(resolve_code_block):   eval() no longer accepts LIST_T, which
	were used before for sequences of expression, instead a sequence
	is now a tuple with first element 'do_sym'.  This is preferable,
	since now expression in the eval function are always TUPLE_T or
	simpler.  Note that the parser generates LIST_T stuff, which is
	resolved by the prules to TUPLE_T.  Repeated resolving TUPLE_T
	doesn't change anything.

	* core.c (for_fn), prelude.rha: for-loops for tuples work, example
	code:

	      t = tuple.new(3);
	      t.set(0, 5);
	      t.set(1, 3);
	      t.set(2, 17);
	      y = 0;
	      for (x in t) y += x;
	      y == 25

2007-08-22  Mikio Braun  <mikiobraun@gmail.com>

	* gtree.h: If FAST_GTREE_LIMIT is defined, the first
	FAST_GTREE_LIMIT - 1 symbols will be stored in a field, not the
	tree. While this reduces lookups to O(1), object creation becomes
	more expensive. For moderate values of FAST_GTREE_LIMIT, for
	example, 12, runtime for fib(25) decreases to 60%.

	* rha_config.pl: symbols are now generated in the order they were
	defined.
	


