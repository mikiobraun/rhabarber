2007-08-23  Stefan Harmeling  <harmeling@gmail.com>

	* tuple_fn.c (tuple_set): now also tuple_set returns the tuple and
	we can do:

	    t = tuple(3).set(0, 17).set(1, 42).set(2, 55);

	* list.rha (fn): added PERL like pop, push, shift, unshift.

	* parse.c (resolve_dots_and_fn_calls): rewrote the whole thing to
	allow magic stuff like:

	     l = list().push(17).push(42);

	* list_fn.c (list_append, list_prepend, list_extend): all of them
	return now the list.

2007-08-23  Mikio Braun  <mikiobraun@gmail.com>

	* object.c (assign): added error message if you try to assign a
	void

2007-08-23  Stefan Harmeling  <harmeling@gmail.com>

	* object.c (to_string): catch the case for 'symbol.proto' which is
	a symbol but has value zero.

	* symbol_fn.c (symbol_name): check for accessing symbol number
	zero.
	

	* rhabarber.c (main): fixed a bug that happens when just pressing
	return at the prompt, now the parse() function might return zero
	which is fine with eval() and fprint("%o").

2007-08-23  Stefan Harmeling  <harmeli@dhcp-153-147.inf.ed.ac.uk>

	* eval.c, rhabarber.c, prules.c, rha_config.pl, object.c, core.c,
	parse.c, eval.c: removed 'void_obj', now 0 is void_obj.  note that
	there is still symbol 'void' which could be internally represented
	by: 
	    object_t void_obj = 0;

	(eval): lookup for void now works...

	* prelude.rha: added for convenience

	    runtest = fn () run(root, "test.rha");

	
2007-08-23  mikio  <mikiobraun@gmail.com>

	* object.c, eval.c, list_fn.c, parse.c, prules.c: added "return
	0;" after "assert(1==0);" to make gcc happy on cygwin (otherwise
	it issued a warning that a function might return without passing a
	value)... .

2007-08-22  Stefan Harmeling  <harmeli@dhcp-153-147.inf.ed.ac.uk>

	* prelude.rha: also added function functionality to 'list', now we
	can construct a list in two ways:

	     l1 = list.new();
	     l2 = list();

	* list_fn.c (list_begin, list_done, list_next, list_get):
	introduced a new rhabarber type 'list_it_t' which is a list
	iterator.  It is used in 'prelude.rha' to define iteration for
	lists, see 'test.rha'.

	* core.c (colon_fn): added case for integers: now 

	     3:7

	becomes

	     (3, 4, 5, 6)

	* object.c (equalequal_fn): added case for strings

	* prelude.rha (fn): besides 

	     t = tuple.new(4);

	we can now also magically say

	     t = tuple(4);

	since we made t a function by adding the relevant slots.

	* prules.c (prules_init): changed priority of quote ('\') to
	10.0.  Now it is equal to all freefix forms and all assignments.
	The reason is:

	     x = \peter              x = \(peter)
	     \x = peter              \(x=peter)

	We see that most prules must be resolved simply from left to
	right.  

	* eval.c (eval_sequence, eval_args_and_call_fun), parse.c
	(resolve_code_block):   eval() no longer accepts LIST_T, which
	were used before for sequences of expression, instead a sequence
	is now a tuple with first element 'do_sym'.  This is preferable,
	since now expression in the eval function are always TUPLE_T or
	simpler.  Note that the parser generates LIST_T stuff, which is
	resolved by the prules to TUPLE_T.  Repeated resolving TUPLE_T
	doesn't change anything.

	* core.c (for_fn), prelude.rha: for-loops for tuples work, example
	code:

	      t = tuple.new(3);
	      t.set(0, 5);
	      t.set(1, 3);
	      t.set(2, 17);
	      y = 0;
	      for (x in t) y += x;
	      y == 25

2007-08-22  Mikio Braun  <mikiobraun@gmail.com>

	* gtree.h: If FAST_GTREE_LIMIT is defined, the first
	FAST_GTREE_LIMIT - 1 symbols will be stored in a field, not the
	tree. While this reduces lookups to O(1), object creation becomes
	more expensive. For moderate values of FAST_GTREE_LIMIT, for
	example, 12, runtime for fib(25) decreases to 60%.

	* rha_config.pl: symbols are now generated in the order they were
	defined.
	


