#include <stdarg.h>
#include <assert.h>
#include <stdio.h>
#include <setjmp.h>
#include "eval.h"
#include "object.h"
#include "rha_types.h"
#include "messages.h"
#include "debug.h"
#include "alloc.h"
#include "utils.h"
#include "excp.h"
#include "list_fn.h"
#include "tuple_fn.h"
#include "symbol_fn.h"

void eval_init(any_t root, any_t module)
{
  // the only two functions we need to pull by hand (and not in prelude.rha)
  assign(root, eval_sym, lookup(module, eval_sym));
  assign(root, callslot_sym, lookup(module, callslot_sym));
}

//----------------------------------------------------------------------
// forward declarations

static any_t eval_args_and_call_fun(any_t env, tuple_t expr);
static any_t eval_sequence(any_t env, tuple_t t);
static list_t get_fn_data(any_t fn);
static bool_t signature_matches(tuple_t signature, bool_t varargs, tuple_t values);
#ifdef _NOT_NOW_
static bool_t pattern_lessthan_pattern(any_t p1, any_t p2);
#endif
static bool_t pattern_matches(any_t pattern, any_t value);
static any_t call_builtin_fun(any_t fnbody,tuple_t values, bool_t no_frame);
static any_t call_rhabarber_fun(any_t this, any_t fn, any_t scope, any_t fnbody,
				tuple_t signature, tuple_t values, bool_t no_frame);
static any_t construct_fun_scope(any_t this, any_t fn, tuple_t values, any_t scope);

// guarded get functions
static tuple_t get_slot_tuple(any_t x, symbol_t s, string_t msg);
static bool_t get_slot_bool(any_t x, symbol_t s, string_t msg);
static any_t get_slot_any(any_t x, symbol_t s, string_t msg);

// auxillary functions
static tuple_t eval_tuple_each(any_t env, tuple_t expr);
static bool_t is_fun_call_of(tuple_t expr, symbol_t sym);

/*************************************************************
 *
 * Frames for 'return', 'break'
 *
 ************************************************************/

// Frames can be opened by functions, loops.  The keyword
// 'return' finishes the most recent function and returns its
// argument, 'break' the most recent loop
//
// Note that these stacks must be only changed via the macros defined
// in eval.h.

jmp_buf frame_stack[FRAME_MAX_NESTING];
any_t frame_value[FRAME_MAX_NESTING];
int frame_type[FRAME_MAX_NESTING];
int frame_tos = -1;
char *frame_names[] = { "function", "loop", "block", "try" };

void _print_frames()
{
  fprintf(stderr, "FRAME[");
  for(int i = 0; i <= frame_tos; i++) {
    fprintf(stderr, frame_names[frame_type[i]]);
    if (i != frame_tos)
      fprintf(stderr, ", ");
  }
  fprintf(stderr, "]\n");
}

//////////////////////////////////////////////////////////////////////
//
// The EVALuator
//

any_t eval(any_t env, any_t expr)
{
  //debug("eval(env=%p, expr=%o)\n", env, expr);
  
  any_t value;
  
  switch (ptype(expr)) {
  case SYMBOL_T: {
    // symbol
    symbol_t s = UNWRAP_SYMBOL(expr);
    value = lookup(env, s);
    if (!value && s!=void_sym) 
      rha_error("lookup of symbol '%o' failed", expr);
    if (has(value, hasproxy_sym)) {
      value = callslot(value, hasproxy_sym, 0);
    }
    return value;
  }
  case TUPLE_T: 
    // function call
    assert(UNWRAP_PTR(TUPLE_T, expr));
    return eval_args_and_call_fun(env, UNWRAP_PTR(TUPLE_T, expr));
  case STRING_T:
    // string literals (must be copied, since they might be modified)
    return WRAP_PTR(STRING_T, string_copy(UNWRAP_PTR(STRING_T, expr)));
  case BOOL_T:
  case INT_T:
  case REAL_T:
    // other literals generated by the parser
    // (must be copied as well, since they might be modified)
    return copy_pt(expr);
  default:
    if (expr == 0) // void
      // do nothing
      return expr;
    // else don't know!
    rha_error("(eval) don't know how to evaluate '%o'", expr);
    assert(1==0);
  }
  return 0; // make gcc happy!
}

//----------------------------------------------------------------------
//
// calling functions
//
// Overview: (this attempts to be something like a call graph)
//
// (do ...) -> eval_sequence
// else -> call_fun
//       

static 
any_t eval_args_and_call_fun(any_t env, tuple_t expr)
{
  //debug("eval_args_and_call_fun: %o\n", WRAP_PTR(TUPLE_T, expr));

  int tlen = tuple_len(expr);
  assert(tlen>0);  // otherwise repair 'rhaparser.y'

  // deal with special stuff
  if (is_fun_call_of(expr, quote_sym)) {
    assert(tlen==2);  // otherwise repair 'rhaparser.y'
    return tuple_get(expr, 1);
  }
  else if (is_fun_call_of(expr, do_sym))
    return eval_sequence(env, expr);

  // evaluate all arguments
  tuple_t values = eval_tuple_each(env, expr);

  // call the function
  return call_fun(env, values);
}


// handle (do ... ) ----------------------------------------------------

// evaluate arguments sequentially
//
// opens a BLOCK_FRAME
static 
any_t eval_sequence(any_t env, tuple_t t)
{
  // either the value of the last expression is delivered
  // or the value following 'deliver'
  // eval_sequence does not open a new scope
  any_t res = 0;
  int_t tlen = tuple_len(t);
  begin_frame(BLOCK_FRAME)
    // evaluate all, or stop earlier via 'deliver', 'break', 'return'
    // note: the counter begins at 1 to ignore 'do_sym'
    for (int i = 1; i < tlen; i++)
      res = eval(env, tuple_get(t, i));
  end_frame(res);
  // return the result
  return res;
}


// calling a function --------------------------------------------------

// Call a function 
//
// searches for the matching implementation, collect the information and
// call the function.
//
// Also called from parse.c!
any_t call_fun(any_t this, tuple_t values)
{
  // get the function to be called and the arguments
  any_t fn = tuple_get(values, 0);
  values = tuple_shift(values);
  
  // look for 'fn_data' which contains all information for the
  // overloaded function
  list_t fn_data_l = get_fn_data(fn);

  // these are the variables which we need below
  any_t impl = 0; // this will be checked afterwards
  tuple_t signature = 0;
  bool_t varargs = false;
  any_t fnbody = 0;
  any_t scope = 0;
  bool_t no_frame = false;

  // vanilla error message for any kind of screw up in fn_data
  string_t msg = "(eval) can't call %o, since it has a faulty entry in 'fn_data'";

  // go through list and look for matching signatures
  for (list_it_t it = list_begin(fn_data_l); !list_done(it); list_next(it)) {
    impl = list_get(it);
    if (!impl) rha_error(msg);

    signature = get_slot_tuple(impl, signature_sym, msg);
    varargs = get_slot_bool(impl, varargs_sym, msg);

    if (signature_matches(signature, varargs, values))
      // match found!!!
      break;
  }
  
  if (!impl) {
    // we did not find anything matching
    rha_error("no matching signature found");
  }

  // collect remaining information
  fnbody = get_slot_any(impl, fnbody_sym, 
			"(eval) can't find function body");
  no_frame = has(impl, no_frame_sym);

  // call function
  if (ptype(fnbody) == BUILTIN_T)
    return call_builtin_fun(fnbody, values, no_frame);
  else {
    scope = get_slot_any(impl, scope_sym, 
			 "(eval) can't find defining scope");
    
    // construct the inner scope

    return call_rhabarber_fun(this, fn, scope, fnbody, signature, 
			      values, no_frame);
  }

  return 0;
}

// get fn.fn_data as a list
static list_t get_fn_data(any_t fn)
{
  any_t fn_data = lookup(fn, fn_data_sym);
  list_t fn_data_l = 0;
  if (!fn_data)
    rha_error("(eval) %o can't be called, since it "
	      "has no 'fn_data' slot", fn);
  if (ptype(fn_data) != LIST_T
      || list_len(fn_data_l = UNWRAP_PTR(LIST_T, fn_data)) == 0)
    rha_error("(eval) %o can't be called, since it "
	      "has a faulty 'fn_data' slot", fn);
  return fn_data_l;
}


// matching signatures -------------------------------------------------

// compare a signature against given arguments
bool_t signature_matches(tuple_t signature, bool_t varargs, tuple_t values)
{
  int_t nsig = tuple_len(signature);
  int_t narg = tuple_len(values);
  // check whether there are enough arguments
  if (varargs) {
    if (nsig > narg)
      return false;
  }
  else {
    if (nsig != narg)
      return false;
  }
  // lexicographical order
  for (int i = 0; i < nsig; i++) {
    any_t pattern = tuple_get(signature, i);
    if (!pattern_matches(pattern, tuple_get(values, i)))
      return false;
  }
  // all checks passed
  return true;
}


#ifdef _NOT_NOW_
static
bool_t pattern_lessthan_pattern(any_t p1, any_t p2)
{
  return true;
}
#endif


static
bool_t pattern_matches(any_t pattern, any_t value)
{
  assert(pattern);  // at least it should exist, even if it doesn't
		    // have slots.
  any_t theliteral = lookup(pattern, symbol_new("patternliteral"));
  any_t thetype = lookup(pattern, symbol_new("patterntype"));
  if (theliteral && ptype(theliteral)!=SYMBOL_T) {
    if (equalequal_fn(theliteral, value))
      return true;
    else
      return false;
  }
  else {
    if (thetype) {
      // check the type
      any_t res = callslot(thetype, check_sym, 1, value);
      if (!res || ptype(res)!=BOOL_T)
	rha_error("(signature) type %o doesn't implement a valid 'check'", thetype);
      if (UNWRAP_BOOL(res))
	return true;
      else
	return false;
    }
    else
      // don't check the type
      return true;
  }
}


// calling a builtin function ------------------------------------------

static any_t call_builtin_fun(any_t fnbody, tuple_t values, bool_t no_frame)
{
  // (1) function with C code
  any_t res = 0;
  builtin_t f = UNWRAP_BUILTIN(fnbody);
  if(no_frame)
    res = f(values);
  else {
    begin_frame(FUNCTION_FRAME)
      res = f(values);
    end_frame(res);
  }
  return res;
}


// calling a rhabarber function ----------------------------------------

// call the found matching implementation
static 
any_t call_rhabarber_fun(any_t this, any_t fn, any_t scope, any_t fnbody,
			 tuple_t signature, tuple_t values, bool_t no_frame)
{
  any_t local = construct_fun_scope(this, fn, values, scope);

  // call the function
  any_t res = 0;
    
  // assign the arguments
  int nsig = tuple_len(signature);
  for(int i = 0; i < nsig; i++) {
    any_t pattern = tuple_get(signature, i);
    if (!pattern)
      rha_error("(eval) signature is not valid");
    any_t s_o = get_slot_any(pattern, symbol_new("patternliteral"), 
			     "(eval) patternliteral expected");
    if (ptype(s_o) == SYMBOL_T) {
      symbol_t s = UNWRAP_SYMBOL(s_o);
      //debug("assigning argument number %d to '%s'\n", i, symbol_name(s));
      assign(local, s, tuple_get(values, i));
    }
  }

  if(no_frame)
    res = eval(local, fnbody);
  else {
    begin_frame(FUNCTION_FRAME)
      res = eval(local, fnbody);
    end_frame(res);
  }
  return res;
}

// construct the local scope for the function call
static 
any_t construct_fun_scope(any_t this, any_t fn, tuple_t values, any_t scope)
{
  any_t local = new();
  assign(local, local_sym, local);   // the scope local to the function
  assign(local, this_sym, this);     // the calling scope
  assign(local, static_sym, fn);     // for static variables
  assign(local, args_sym, WRAP_PTR(TUPLE_T, values)); // all passed arguments
  assign(local, parent_sym, scope);  // the defining scope (lexical)
  return local;
}

//----------------------------------------------------------------------
//
// functions for calling a slot
//

// note on "variable argument lists" in rhabarber:
// to pull in a function like 'callslot' with '...' automatically, we
// need to implement a function 'vcallclot' with the '...' replaced by
// a 'list_t' argument.
// NOTE: we assume that the last required argument is an integer that
// tells the C function (e.g. 'callslot') how long the list really
// is.  The 'v' version of the function doesn't have it.
any_t vcallslot(any_t obj, symbol_t slotname, tuple_t args)
{
  // note that 'callslot' assumes that all arguments are already
  // evaluated in the outer calling scope.  this is important since we
  // have no longer access to the outer calling scope.  the inner
  // calling scope ('this') will be set to 'obj'
  //debug("callslot(%o, %o, %o)\n", obj, WRAP_SYMBOL(slotname), WRAP_PTR(TUPLE_T, args));
  any_t slot = lookup(obj, slotname);
  if (!slot)
    throw(excp_newf("(call_slot) object %o doesn't have slot '%s'",
		    obj, symbol_name(slotname)));
  
  // construct the call
  list_t args_l = tuple_to_list(args);
  list_prepend(args_l, slot);

  // call the slot with the scope being the object
  return call_fun(obj, list_to_tuple(args_l));
}


// note that:
// * calling 'callslot' in C calls 'callslot'
// * calling 'callslot' in Rhaberber calls 'vcallslot'
any_t callslot(any_t obj, symbol_t slotname, int_t narg, ...)
{
  //debug("callslot(%o, %o, %d, ...)\n", obj, WRAP_SYMBOL(slotname), narg);
  va_list ap;
  va_start(ap, narg);
  tuple_t args = tuple_new(narg);
  for (int i = 0; i < narg; i++)
    tuple_set(args, i, va_arg(ap, any_t));
  va_end(ap);
  
  return vcallslot(obj, slotname, args);
}

//----------------------------------------------------------------------
//
// guarded get functions
//
// get a slot, check the type, raise error if slot does not exist or
// does not have the correct type!
//

static
tuple_t get_slot_tuple(any_t x, symbol_t s, string_t msg)
{
  any_t o = lookup(x, s);
  if (!o || ptype(o) != TUPLE_T)
    rha_error(msg);
  return UNWRAP_PTR(TUPLE_T, o);
}

static
bool_t get_slot_bool(any_t x, symbol_t s, string_t msg)
{
  any_t o = lookup(x, s);
  if (!o || ptype(o) != BOOL_T)
    rha_error(msg);
  return UNWRAP_BOOL(o);
}

static 
any_t get_slot_any(any_t x, symbol_t s, string_t msg)
{
  any_t o = lookup(x, s);
  if (!o)
    rha_error(msg);
  return o;
}

//----------------------------------------------------------------------
// 
// Some auxillary functions
//

// check whether expr is a call with symbol sym
static
bool_t is_fun_call_of(tuple_t expr, symbol_t sym)
{
  any_t f = tuple_get(expr, 0);
  return (ptype(f) == SYMBOL_T)
    && (UNWRAP_SYMBOL(f) == sym);
}


// evaluate each member of a tuple, returning the result
static
tuple_t eval_tuple_each(any_t env, tuple_t expr)
{
  int tlen = tuple_len(expr);

  tuple_t values = tuple_new(tlen);
  for (int i=0; i<tlen; i++)
    tuple_set(values, i, eval(env, tuple_get(expr, i)));
  return values;
}
