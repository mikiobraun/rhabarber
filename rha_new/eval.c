#include <stdarg.h>
#include <assert.h>
#include <stdio.h>
#include <setjmp.h>
#include "eval.h"
#include "object.h"
#include "rha_types.h"
#include "messages.h"
#include "debug.h"
#include "alloc.h"
#include "utils.h"
#include "excp.h"
#include "list_fn.h"
#include "tuple_fn.h"
#include "symbol_fn.h"
#include "prules.h"

void eval_init(any_t root, any_t module)
{
  // the only two functions we need to pull by hand (and not in prelude.rha)
  assign(root, eval_sym, lookup(module, eval_sym));
  assign(root, callslot_sym, lookup(module, callslot_sym));
}

//----------------------------------------------------------------------
// forward declarations

static any_t eval_args_and_call_fun(any_t env, tuple_t expr);
static any_t eval_sequence(any_t env, tuple_t t);
static list_t get_fn_data(any_t fn);
static bool signature_matches(tuple_t signature, bool varargs, tuple_t values);
static bool pattern_matches(any_t pattern, any_t value);
static any_t call_builtin_fun(any_t fnbody, tuple_t values, bool no_frame);
static any_t call_ccode_fun(any_t fnbody, tuple_t values, bool no_frame);
static any_t call_rhabarber_fun(any_t this, any_t fn, any_t scope, any_t fnbody,
				tuple_t signature, tuple_t values, bool no_frame);
static any_t construct_fun_scope(any_t this, any_t fn, tuple_t values, any_t scope);

// guarded get functions
static tuple_t get_slot_tuple(any_t x, symbol_t s, string_t msg);
static bool get_slot_bool(any_t x, symbol_t s, string_t msg);
static any_t get_slot_any(any_t x, symbol_t s, string_t msg);

// auxillary functions
static tuple_t eval_tuple_each(any_t env, tuple_t expr);
static bool is_fun_call_of(tuple_t expr, symbol_t sym);

/*************************************************************
 *
 * Frames for 'return', 'break'
 *
 ************************************************************/

// Frames can be opened by functions, loops.  The keyword
// 'return' finishes the most recent function and returns its
// argument, 'break' the most recent loop
//
// Note that these stacks must be only changed via the macros defined
// in eval.h.

jmp_buf frame_stack[FRAME_MAX_NESTING];
any_t frame_value[FRAME_MAX_NESTING];
int frame_type[FRAME_MAX_NESTING];
int frame_tos = -1;
char *frame_names[] = { "function", "loop", "block", "try" };

void _print_frames(void)
{
  fprintf(stderr, "FRAME[");
  for(int i = 0; i <= frame_tos; i++) {
    fprintf(stderr, frame_names[frame_type[i]]);
    if (i != frame_tos)
      fprintf(stderr, ", ");
  }
  fprintf(stderr, "]\n");
}

//////////////////////////////////////////////////////////////////////
//
// The EVALuator
//

any_t eval(any_t env, any_t expr)
{
  //debug("eval(env=%p, expr=%o)\n", env, expr);
  
  any_t value;
  
  switch (ptype(expr)) {
  case RHA_symbol_t: {
    // symbol
    symbol_t s = UNWRAP_SYMBOL(expr);
    value = lookup(env, s);
    if (!value)
      rha_error("lookup of symbol '%o' failed", expr);
    if (has(value, hasproxy_sym)) {
      value = callslot(value, hasproxy_sym, 0);
    }
    return value;
  }
  case RHA_tuple_t: 
    // function call
    assert(UNWRAP_PTR(RHA_tuple_t, expr));
    return eval_args_and_call_fun(env, UNWRAP_PTR(RHA_tuple_t, expr));
  case RHA_string_t:
    // string literals (must be copied, since they might be modified)
    return WRAP_PTR(RHA_string_t, string_copy(UNWRAP_PTR(RHA_string_t, expr)));
  case RHA_bool:
  case RHA_int:
  case RHA_real_t:
    // other literals generated by the parser
    // (must be copied as well, since they might be modified)
    return copy_pt(expr);
  default:
    if (expr == 0 || expr == void_obj) // void
      // do nothing
      return expr;
    // else don't know!
    rha_error("(eval) don't know how to evaluate '%o'", expr);
    assert(1==0);
  }
  return 0; // make gcc happy!
}

//----------------------------------------------------------------------
//
// calling functions
//
// Overview: (this attempts to be something like a call graph)
//
// (do ...) -> eval_sequence
// else -> call_fun
//       

static 
any_t eval_args_and_call_fun(any_t env, tuple_t expr)
{
  //debug("eval_args_and_call_fun: %o\n", WRAP_PTR(TUPLE_T, expr));

  int tlen = tuple_len(expr);
  assert(tlen>0);  // otherwise repair 'rhaparser.y'

  // deal with special stuff
  if (is_fun_call_of(expr, quote_sym)) {
    assert(tlen==2);  // otherwise repair 'rhaparser.y'
    return tuple_get(expr, 1);
  }
  else if (is_fun_call_of(expr, do_sym))
    return eval_sequence(env, expr);

  // evaluate all arguments
  tuple_t values = eval_tuple_each(env, expr);

  // call the function
  return call_fun(env, values);
}


// handle (do ... ) ----------------------------------------------------

// evaluate arguments sequentially
//
// opens a BLOCK_FRAME
static 
any_t eval_sequence(any_t env, tuple_t t)
{
  // either the value of the last expression is delivered
  // or the value following 'deliver'
  // eval_sequence does not open a new scope
  any_t res = 0;
  int tlen = tuple_len(t);
  begin_frame(BLOCK_FRAME)
    // evaluate all, or stop earlier via 'deliver', 'break', 'return'
    // note: the counter begins at 1 to ignore 'do_sym'
    for (int i = 1; i < tlen; i++)
      res = eval(env, tuple_get(t, i));
  end_frame(res);
  // return the result
  return res;
}


// calling a function --------------------------------------------------

// Call a function 
//
// searches for the matching implementation, collect the information and
// call the function.
//
// Also called from parse.c to execute prules!
any_t call_fun(any_t this, tuple_t values)
{
  // get the function to be called and the arguments
  any_t fn = tuple_get(values, 0);
  values = tuple_shift(values);
  
  // look for 'fn_data' which contains all information for the
  // overloaded function
  list_t fn_data_l = get_fn_data(fn);

  // these are the variables which we need below
  any_t impl = 0; // this will be checked afterwards
  tuple_t signature = 0;
  bool varargs = false;
  any_t fnbody = 0;
  any_t scope = 0;
  bool no_frame = false;

  // vanilla error message for any kind of screw up in fn_data
  string_t msg = "(eval) can't call %o, since it has a faulty entry in 'fn_data'";

  // go through list and look for matching signatures
  list_it_t it = list_begin(fn_data_l);
  while (!list_done(it)) {
    any_t theimpl = list_get(it);
    if (!theimpl) rha_error(msg);
    
    signature = get_slot_tuple(theimpl, signature_sym, msg);
    varargs = get_slot_bool(theimpl, varargs_sym, msg);
    
    if (signature_matches(signature, varargs, values)) {
      // first match found!!!
      impl = theimpl;
      break;
    }
    list_next(it);
  }
  
  if (!impl) {
    // we did not find anything matching
    rha_error("no matching signature found");
  }

  // collect remaining information
  fnbody = get_slot_any(impl, fnbody_sym, "(eval) can't find function body");
  no_frame = has(impl, no_frame_sym);

  // call function
  if (ptype(fnbody) == RHA_builtin_t)
    return call_builtin_fun(fnbody, values, no_frame);
  else if (ptype(fnbody) == RHA_ccode_t)
    return call_ccode_fun(fnbody, values, no_frame);
  else {
    scope = get_slot_any(impl, scope_sym, 
			 "(eval) can't find defining scope");
    return call_rhabarber_fun(this, fn, scope, fnbody, signature, 
			      values, no_frame);
  }

  return 0;
}

// get fn.fn_data as a list
static list_t get_fn_data(any_t fn)
{
  any_t fn_data = lookup(fn, fn_data_sym);
  list_t fn_data_l = 0;
  if (!fn_data)
    rha_error("(eval) %o can't be called, since it "
	      "has no 'fn_data' slot", fn);
  if (ptype(fn_data) != RHA_list_t
      || list_len(fn_data_l = UNWRAP_PTR(RHA_list_t, fn_data)) == 0)
    rha_error("(eval) %o can't be called, since it "
	      "has a faulty 'fn_data' slot", fn);
  return fn_data_l;
}


// matching signatures -------------------------------------------------

// compare a signature against given arguments
bool signature_matches(tuple_t signature, bool varargs, tuple_t values)
{
  int nsig = tuple_len(signature);
  int narg = tuple_len(values);
  // check whether there are enough arguments
  if (varargs) {
    if (nsig > narg)
      return false;
  }
  else {
    if (nsig != narg)
      return false;
  }
  // lexicographical order
  for (int i = 0; i < nsig; i++) {
    any_t pattern = tuple_get(signature, i);
    if (!pattern_matches(pattern, tuple_get(values, i)))
      return false;
  }
  // all checks passed
  return true;
}

static
bool pattern_valid(any_t p)
{
  assert(p);
  any_t thelit = lookup(p, patternliteral_sym);
  any_t thetyp = lookup(p, patterntype_sym);
  // if there is a type, then 
  //    either there is no literal 
  //    or the literal is a symbol
  if (thetyp) return (thelit == 0 || ptype(thelit) == RHA_symbol_t);
  // otherwise everything is fine
  return true;
}


bool pattern_equalequal(any_t p1, any_t p2)
{
  if (!pattern_valid(p1) || !pattern_valid(p2))
    rha_error("(pattern) the patterns are invalid");
  any_t thelit1 = lookup(p1, patternliteral_sym);
  any_t thetyp1 = lookup(p1, patterntype_sym);
  any_t thelit2 = lookup(p2, patternliteral_sym);
  any_t thetyp2 = lookup(p2, patterntype_sym);
  // CASE 1
  // if p1 is a (non-symbol) literal then it is equal to p2 only if it
  // is the same literal
  if (thelit1 && ptype(thelit1) != RHA_symbol_t) 
    return (thelit2 && equalequal_fn(thelit1, thelit2));
  // CASE 2
  // we know that p1 is not a (non-symbol) literal, thus it is either
  // zero or a symbol.
  // if p1 is a type then it is equal to p2 only if it is the same type
  if (thetyp1) return (thetyp2 && thetyp1 == thetyp2);
  // CASE 3
  // we know that p1 is neither a literal nor a type, so it is 'any'
  // and so must be p2
  return !thetyp2;
}

bool pattern_lessthan(any_t p1, any_t p2)
// examples:
//     17 < x         // literals smaller than non-literals
//     int:x < any:x
//     int:x < x
// is p1 more special than p2?
//     true  --> yes
//     false --> don't know
{
  if (!pattern_valid(p1) || !pattern_valid(p2))
    rha_error("(pattern) the patterns are invalid");
  any_t thelit1 = lookup(p1, patternliteral_sym);
  any_t thetyp1 = lookup(p1, patterntype_sym);
  any_t thelit2 = lookup(p2, patternliteral_sym);
  any_t thetyp2 = lookup(p2, patterntype_sym);
  // CASE 1
  // if p1 is a (non-symbol) literal then it is more special than p2
  // only if p2 is not a (non-symbol) literal, otherwise they are incomparable
  // and we return false
  if (thelit1 && ptype(thelit1)!=RHA_symbol_t) 
    return (!thelit2 || ptype(thelit2)==RHA_symbol_t);
  // CASE 2
  // we know that p1 is not a (non-symbol) literal
  // if p1 is a type then it is more special than p2 only if p2 is a
  // type as well, and p2:p1 holds
  if (thetyp1) return (!thetyp2 || callslot(thetyp2, isparent_sym, 1, thetyp1));
  // CASE 3
  // we know that p1 is neither a literal nor a type, so it is 'any'
  // which is the most general and wont be more special than p2
  return false;
}


bool signature_equalequal(tuple_t sig1, tuple_t sig2)
{
  // compare lexicographically
  int tlen = tuple_len(sig1);
  if (tlen != tuple_len(sig2))
    // not equal
    return false;
  for (int i = 0; i < tlen; i++) {
    any_t p1 = tuple_get(sig1, i);
    any_t p2 = tuple_get(sig2, i);
    if (!pattern_equalequal(p1, p2))
      return false;
  }
  // they are equal
  return true;
}


bool signature_lessthan(tuple_t sig1, tuple_t sig2)
{
  // compare lexicographically
  int tlen = tuple_len(sig1);
  if (tlen != tuple_len(sig2))
    // incomparable due to different length and thus not "lessthan"
    return false;
  for (int i = 0; i < tlen; i++) {
    any_t p1 = tuple_get(sig1, i);
    any_t p2 = tuple_get(sig2, i);
    if (pattern_lessthan(p1, p2))
      // equal so far and now lessthan
      return true;
    if (!pattern_equalequal(p1, p2))
      // equal so far and now neither "lessthan" nor equal
      return false;
  }
  // they are equal, but not "lessthan"
  return false;
}

tuple_t get_signature(any_t obj)
{
  obj = get_slot_any(obj, signature_sym, "signature expected");
  if (ptype(obj) != RHA_tuple_t)
    rha_error("broken signature");
  return UNWRAP_PTR(RHA_tuple_t, obj);
}

bool fn_data_entry_equalequal(any_t e1, any_t e2)
{
  return signature_equalequal(get_signature(e1), get_signature(e2));
}

bool fn_data_entry_lessthan(any_t e1, any_t e2)
{
  return signature_lessthan(get_signature(e1), get_signature(e2));
}


static
bool pattern_matches(any_t pattern, any_t value)
{
  if (!pattern_valid(pattern))
    rha_error("(pattern) invalid pattern");
  any_t theliteral = lookup(pattern, patternliteral_sym);
  any_t thetype = lookup(pattern, patterntype_sym);
  if (theliteral && ptype(theliteral)!=RHA_symbol_t) {
    if (equalequal_fn(theliteral, value))
      return true;
    else
      return false;
  }
  else {
    if (thetype) {
      // check the type
      any_t res = callslot(thetype, check_sym, 1, value);
      if (!res || ptype(res)!=RHA_bool)
	rha_error("(signature) type %o doesn't implement a valid 'check'",
		  thetype);
      if (UNWRAP_BOOL(res))
	return true;
      else
	return false;
    }
    else
      // don't check the type
      return true;
  }
}


// calling a builtin function ------------------------------------------

static any_t call_builtin_fun(any_t fnbody, tuple_t values, bool no_frame)
{
  // (1) function with C code
  any_t res = 0;
  builtin_t f = UNWRAP_BUILTIN(fnbody);
  // replace all 'void_obj' by zeroes
  for (int i = 0; i < tuple_len(values); i++) {
    any_t value = tuple_get(values, i);
    //assert(value); // void in values should right now not be zero but void_obj
    if (value == void_obj)
      tuple_set(values, i, 0);
  }
  if(no_frame)
    res = f(values);
  else {
    begin_frame(FUNCTION_FRAME)
      res = f(values);
    end_frame(res);
  }
  return res;
}

static any_t call_ccode_fun_narg(ccode_t c, tuple_t values, int narg)
{
  code_t f = c.code;
  ptype_t rptype = c.rptype;
  union raw_t vres;
  switch (narg) {
  case 0:
    vres = f(0);
    break;
  case 1:    
    vres = f(1, 
	     tuple_get(values, 0)->raw);    
    break;
  case 2:
    vres = f(2, 
	     tuple_get(values, 0)->raw,
	     tuple_get(values, 1)->raw);    
    break;
  case 3:
    vres = f(3, 
	     tuple_get(values, 0)->raw,
	     tuple_get(values, 1)->raw,
	     tuple_get(values, 2)->raw);    
    break;
  case 4:
    vres = f(4, 
	     tuple_get(values, 0)->raw,
	     tuple_get(values, 1)->raw,
	     tuple_get(values, 2)->raw,
	     tuple_get(values, 3)->raw);    
    break;
  case 5:
    vres = f(5, 
	     tuple_get(values, 0)->raw,
	     tuple_get(values, 1)->raw,
	     tuple_get(values, 2)->raw,
	     tuple_get(values, 3)->raw,
	     tuple_get(values, 4)->raw);    
    break;
  case 6:
    vres = f(6, 
	     tuple_get(values, 0)->raw,
	     tuple_get(values, 1)->raw,
	     tuple_get(values, 2)->raw,
	     tuple_get(values, 3)->raw,
	     tuple_get(values, 4)->raw,
	     tuple_get(values, 5)->raw);    
    break;
  case 7:
    vres = f(7, 
	     tuple_get(values, 0)->raw,
	     tuple_get(values, 1)->raw,
	     tuple_get(values, 2)->raw,
	     tuple_get(values, 3)->raw,
	     tuple_get(values, 4)->raw,
	     tuple_get(values, 5)->raw,
	     tuple_get(values, 6)->raw);    
    break;
  default:
    rha_error("[eval.c:call_ccode_fun_narg] not implemented for that many arguments");
    break;
  }
  // convert return value to its right type
  any_t res;
  switch (rptype) {
  case RHA_int:	      res = WRAP_INT(vres.i);	      break;
  case RHA_bool:      res = WRAP_BOOL(vres.i);	      break;
  case RHA_symbol_t:  res = WRAP_SYMBOL(vres.i);      break;
  case RHA_real_t:    res = WRAP_REAL(vres.d);        break;
  case RHA_builtin_t: res = WRAP_BUILTIN(vres.b);     break;
  case RHA_ccode_t:   res = WRAP_CCODE(vres.c);       break;
  default:            res = WRAP_PTR(rptype, vres.p); break;
  }
  return res;
}

static any_t call_ccode_fun(any_t fnbody, tuple_t values, bool no_frame)
{
  // (1) function with C code
  any_t res = 0;
  ccode_t c = UNWRAP_CCODE(fnbody);
  int narg = tuple_len(values);
  // replace all 'void_obj' by zeroes
  for (int i = 0; i < narg; i++) {
    any_t value = tuple_get(values, i);
    //assert(value); // void in values should right now not be zero but void_obj
    if (value == void_obj)
      tuple_set(values, i, 0);
  }
  if(no_frame)
    res = call_ccode_fun_narg(c, values, narg);
  else {
    begin_frame(FUNCTION_FRAME)
      res = call_ccode_fun_narg(c, values, narg);
    end_frame(res);
  }
  return res;
}


// calling a rhabarber function ----------------------------------------

// call the found matching implementation
static 
any_t call_rhabarber_fun(any_t this, any_t fn, any_t scope, any_t fnbody,
			 tuple_t signature, tuple_t values, bool no_frame)
{
  any_t local = construct_fun_scope(this, fn, values, scope);

  // call the function
  any_t res = 0;
    
  // assign the arguments
  int nsig = tuple_len(signature);
  for(int i = 0; i < nsig; i++) {
    any_t pattern = tuple_get(signature, i);
    if (!pattern)
      rha_error("(eval) signature is not valid");
    any_t s_o = get_slot_any(pattern, patternliteral_sym, 
			     "(eval) patternliteral expected");
    if (ptype(s_o) == RHA_symbol_t) {
      symbol_t s = UNWRAP_SYMBOL(s_o);
      //debug("assigning argument number %d to '%s'\n", i, symbol_name(s));
      assign(local, s, tuple_get(values, i));
    }
  }

  if(no_frame)
    res = eval(local, fnbody);
  else {
    begin_frame(FUNCTION_FRAME)
      res = eval(local, fnbody);
    end_frame(res);
  }
  return res;
}

// construct the local scope for the function call
static 
any_t construct_fun_scope(any_t this, any_t fn, tuple_t values, any_t scope)
{
  any_t local = new();
  assign(local, local_sym, local);   // the scope local to the function
  assign(local, this_sym, this);     // the calling scope
  assign(local, static_sym, fn);     // for static variables
  assign(local, args_sym, WRAP_PTR(RHA_tuple_t, values)); // all passed arguments
  assign(local, parent_sym, scope);  // the defining scope (lexical)
  return local;
}

//----------------------------------------------------------------------
//
// functions for calling a slot
//

// note on "variable argument lists" in rhabarber:
// to pull in a function like 'callslot' with '...' automatically, we
// need to implement a function 'vcallclot' with the '...' replaced by
// a 'list_t' argument.
// NOTE: we assume that the last required argument is an integer that
// tells the C function (e.g. 'callslot') how long the list really
// is.  The 'v' version of the function doesn't have it.
any_t vcallslot(any_t obj, symbol_t slotname, tuple_t args)
{
  // note that 'callslot' assumes that all arguments are already
  // evaluated in the outer calling scope.  this is important since we
  // have no longer access to the outer calling scope.  the inner
  // calling scope ('this') will be set to 'obj'
  //debug("callslot(%o, %o, %o)\n", obj, WRAP_SYMBOL(slotname), WRAP_PTR(RHA_tuple_t, args));
  any_t slot = lookup(obj, slotname);
  if (!slot)
    throw(excp_newf("(call_slot) object %o doesn't have slot '%s'",
		    obj, symbol_name(slotname)));
  
  // construct the call
  list_t args_l = tuple_to_list(args);
  list_prepend(args_l, slot);

  // call the slot with the scope being the object
  return call_fun(obj, list_to_tuple(args_l));
}


// note that:
// * calling 'callslot' in C calls 'callslot'
// * calling 'callslot' in Rhaberber calls 'vcallslot'
any_t callslot(any_t obj, symbol_t slotname, int narg, ...)
{
  //debug("callslot(%o, %o, %d, ...)\n", obj, WRAP_SYMBOL(slotname), narg);
  va_list ap;
  va_start(ap, narg);
  tuple_t args = tuple_new(narg);
  for (int i = 0; i < narg; i++)
    tuple_set(args, i, va_arg(ap, any_t));
  va_end(ap);
  
  return vcallslot(obj, slotname, args);
}

//----------------------------------------------------------------------
//
// guarded get functions
//
// get a slot, check the type, raise error if slot does not exist or
// does not have the correct type!
//

static
tuple_t get_slot_tuple(any_t x, symbol_t s, string_t msg)
{
  any_t o = lookup(x, s);
  if (!o || ptype(o) != RHA_tuple_t)
    rha_error(msg);
  return UNWRAP_PTR(RHA_tuple_t, o);
}

static
bool get_slot_bool(any_t x, symbol_t s, string_t msg)
{
  any_t o = lookup(x, s);
  if (!o || ptype(o) != RHA_bool)
    rha_error(msg);
  return UNWRAP_BOOL(o);
}

static 
any_t get_slot_any(any_t x, symbol_t s, string_t msg)
{
  any_t o = lookup(x, s);
  if (!o)
    rha_error(msg);
  return o;
}

//----------------------------------------------------------------------
// 
// Some auxillary functions
//

// check whether expr is a call with symbol sym
static
bool is_fun_call_of(tuple_t expr, symbol_t sym)
{
  any_t f = tuple_get(expr, 0);
  return (ptype(f) == RHA_symbol_t)
    && (UNWRAP_SYMBOL(f) == sym);
}


// evaluate each member of a tuple, returning the result
static
tuple_t eval_tuple_each(any_t env, tuple_t expr)
{
  int tlen = tuple_len(expr);

  tuple_t values = tuple_new(tlen);
  for (int i=0; i<tlen; i++)
    tuple_set(values, i, eval(env, tuple_get(expr, i)));
  return values;
}
