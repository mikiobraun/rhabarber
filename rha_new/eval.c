#include <stdarg.h>
#include <assert.h>
#include <stdio.h>
#include <setjmp.h>
#include "eval.h"
#include "object.h"
#include "rha_types.h"
#include "messages.h"
#include "debug.h"
#include "alloc.h"
#include "utils.h"
#include "excp.h"
#include "list_fn.h"
#include "tuple_fn.h"
#include "symbol_fn.h"

void eval_init(any_t root, any_t module)
{
  // the only two functions we need to pull by hand (and not in prelude.rha)
  assign(root, eval_sym, lookup(module, eval_sym));
  assign(root, callslot_sym, lookup(module, callslot_sym));
}

// forward declarations
static any_t eval_sequence(any_t env, tuple_t t);
static any_t eval_args_and_call_fun(any_t env, tuple_t expr);
static any_t find_and_call_matching_impl(any_t local, list_t fn_data_l, tuple_t values, 
					    bool_t no_frame);
static bool_t signature_matches(tuple_t signature, bool_t varargs, tuple_t values);
static any_t call_matching_impl(any_t local, any_t scope, any_t fnbody,
			    tuple_t signature, tuple_t values, bool_t no_frame);

/*************************************************************
 *
 * Frames for 'return', 'break'
 *
 ************************************************************/

// Frames can be opened by functions, loops.  The keyword
// 'return' finishes the most recent function and returns its
// argument, 'break' the most recent loop
//
// Note that these stacks must be only changed via the macros defined
// in eval.h.

jmp_buf frame_stack[FRAME_MAX_NESTING];
any_t frame_value[FRAME_MAX_NESTING];
int frame_type[FRAME_MAX_NESTING];
int frame_tos = -1;
char *frame_names[] = { "function", "loop", "block", "try" };

void _print_frames()
{
  fprintf(stderr, "FRAME[");
  for(int i = 0; i <= frame_tos; i++) {
    fprintf(stderr, frame_names[frame_type[i]]);
    if (i != frame_tos)
      fprintf(stderr, ", ");
  }
  fprintf(stderr, "]\n");
}

//////////////////////////////////////////////////////////////////////
//
// The EVALuator
//

any_t eval(any_t env, any_t expr)
{
  //debug("eval(env=%p, expr=%o)\n", env, expr);
  
  any_t value;
  
  switch (ptype(expr)) {
  case SYMBOL_T: {
    // symbol
    symbol_t s = UNWRAP_SYMBOL(expr);
    value = lookup(env, s);
    if (!value && s!=void_sym) 
      rha_error("lookup of symbol '%o' failed", expr);
    if (has(value, hasproxy_sym)) {
      value = callslot(value, hasproxy_sym, 0);
    }
    return value;
  }
  case TUPLE_T: 
    // function call
    assert(UNWRAP_PTR(TUPLE_T, expr));
    return eval_args_and_call_fun(env, UNWRAP_PTR(TUPLE_T, expr));
  case STRING_T:
    // string literals (must be copied, since they might be modified)
    return WRAP_PTR(STRING_T, string_copy(UNWRAP_PTR(STRING_T, expr)));
  case BOOL_T:
  case INT_T:
  case REAL_T:
    // other literals generated by the parser
    // (must be copied as well, since they might be modified)
    return copy_pt(expr);
  default:
    if (expr == 0) // void
      // do nothing
      return expr;
    // else don't know!
    rha_error("(eval) don't know how to evaluate '%o'", expr);
    assert(1==0);
  }
  return 0; // make gcc happy!
}

//----------------------------------------------------------------------
//
// calling functions
//
// Overview: (this attempts to be something like a call graph)
//
// (do ...) -> eval_sequence
// else -> evaluate all arguments
//         call_fun
//             construct local scope
//             find_and_call_matching_impl
//                  iterate over signatures
//                      if signature_matches
//                          call_matching_impl      

static 
any_t eval_args_and_call_fun(any_t env, tuple_t expr)
{
  int tlen = tuple_len(expr);
  //debug("eval_args: %o\n", WRAP_PTR(TUPLE_T, expr));
  assert(tlen>0);  // otherwise repair 'rhaparser.y'
  any_t f = tuple_get(expr, 0);
  // deal with special stuff
  if (ptype(f)==SYMBOL_T) {
    if (quote_sym == UNWRAP_SYMBOL(f)) {
      assert(tlen==2);  // otherwise repair 'rhaparser.y'
      return tuple_get(expr, 1);
    }
    else if (do_sym == UNWRAP_SYMBOL(f)) {
      return eval_sequence(env, expr);
    }
    //debug("calling '%o'\n", f);
  }

  // otherwise a usual function
  tuple_t values = tuple_new(tlen);
  for (int i=0; i<tlen; i++)
    tuple_set(values, i, eval(env, tuple_get(expr, i)));

  // finally call the function
  return call_fun(env, values);
}

// evaluate arguments sequentially
//
// opens a BLOCK_FRAME
static 
any_t eval_sequence(any_t env, tuple_t t)
{
  // either the value of the last expression is delivered
  // or the value following 'deliver'
  // eval_sequence does not open a new scope
  any_t res = 0;
  int_t tlen = tuple_len(t);
  begin_frame(BLOCK_FRAME)
    // evaluate all, or stop earlier via 'deliver', 'break', 'return'
    // note: the counter begins at 1 to ignore 'do_sym'
    for (int i = 1; i < tlen; i++)
      res = eval(env, tuple_get(t, i));
  end_frame(res);
  // return the result
  return res;
}

// Call a function 
//
// Checks if the number of argument matches, constructs the local
// environment of the callee and executes the function
//
// callable objects must have the 'fn_data' slot
any_t call_fun(any_t this, tuple_t values)
{
  list_t values_l = tuple_to_list(values);

  // get the function to be called
  any_t fn = list_popfirst(values_l);
  values = list_to_tuple(values_l);
  
  // look for 'fn_data' which contains all information for the
  // overloaded function
  any_t fn_data = lookup(fn, fn_data_sym);
  list_t fn_data_l = 0;
  if (!fn_data)
    rha_error("(eval) %o can't be called, since it "
	      "has no 'fn_data' slot", fn);
  if (ptype(fn_data)!=LIST_T
      || list_len(fn_data_l=UNWRAP_PTR(LIST_T, fn_data)) == 0)
    rha_error("(eval) %o can't be called, since it "
	      "has a faulty 'fn_data' slot", fn);

  bool_t no_frame = has(fn_data, no_frame_sym);

  // construct the inner scope
  any_t local = new();
  assign(local, local_sym, local);   // the scope local to the function
  assign(local, this_sym, this);     // the calling scope
  assign(local, static_sym, fn);     // for static variables
  assign(local, args_sym, WRAP_PTR(TUPLE_T, values)); // all passed arguments

  // find and call the matching implementation
  return find_and_call_matching_impl(local, fn_data_l, values, no_frame);
}


// go through available implementations and call the first one which matches
//
// calls: signature_matches, call_matching_impl
static 
any_t find_and_call_matching_impl(any_t local, list_t fn_data_l, tuple_t values,
				     bool_t no_frame)
{
  //debug("find_and_call_matching_impl(%o, %o, %o)\n", local, WRAP_PTR(LIST_T, fn_data_l), WRAP_PTR(TUPLE_T, values));
  string_t msg = "(eval) can't call %o, since it has a faulty entry in 'fn_data'";
  // go through the list to find a match
  for (list_it_t it = list_begin(fn_data_l); !list_done(it); list_next(it)) {
    any_t impl = list_get(it);
    if (!impl) rha_error(msg);
    any_t signature_o = lookup(impl, signature_sym); 
    if (!signature_o || ptype(signature_o)!=TUPLE_T)
      rha_error(msg);
    tuple_t signature = UNWRAP_PTR(TUPLE_T, signature_o);
    any_t varargs_o = lookup(impl, varargs_sym);
    if (!varargs_o || ptype(varargs_o)!=BOOL_T)
      rha_error(msg);
    bool_t varargs = UNWRAP_BOOL(varargs_o);
    if (signature_matches(signature, varargs, values)) {
      // match found!!!
      any_t fnbody = lookup(impl, fnbody_sym);
      if (!fnbody)
	rha_error("(eval) can't find function body");
      any_t scope = lookup(impl, scope_sym);
      // note that for builtin functions the 'scope' is ignored and
      // can thus also be 'void'
      if (!scope && ptype(fnbody)!=BUILTIN_T)
	rha_error("(eval) can't find defining scope");
      return call_matching_impl(local, scope, fnbody, signature, values, no_frame);
    }
  }
  // we did not find anything matching
  rha_error("no matching signature found");
  return 0;
}


bool_t pattern_lessthan_pattern(any_t p1, any_t p2)
{
  return true;
}

bool_t pattern_matches(any_t pattern, any_t value)
{
  assert(pattern);  // at least it should exist, even if it doesn't
		    // have slots.
  any_t theliteral = lookup(pattern, symbol_new("patternliteral"));
  any_t thetype = lookup(pattern, symbol_new("patterntype"));
  if (theliteral && ptype(theliteral)!=SYMBOL_T) {
    if (equalequal_fn(theliteral, value))
      return true;
    else
      return false;
  }
  else {
    if (thetype) {
      // check the type
      any_t res = callslot(thetype, check_sym, 1, value);
      if (!res || ptype(res)!=BOOL_T)
	rha_error("(signature) type %o doesn't implement a valid 'check'", thetype);
      if (UNWRAP_BOOL(res))
	return true;
      else
	return false;
    }
    else
      // don't check the type
      return true;
  }
}


// compare a signature against given arguments
bool_t signature_matches(tuple_t signature, bool_t varargs, tuple_t values)
{
  int_t nsig = tuple_len(signature);
  int_t narg = tuple_len(values);
  // check whether there are enough arguments
  if (varargs) {
    if (nsig > narg)
      return false;
  }
  else {
    if (nsig != narg)
      return false;
  }
  // lexicographical order
  for (int i = 0; i < nsig; i++) {
    any_t pattern = tuple_get(signature, i);
    if (!pattern_matches(pattern, tuple_get(values, i)))
      return false;
  }
  // all checks passed
  return true;
}



// call the found matching implementation
static 
any_t call_matching_impl(any_t local, any_t scope, any_t fnbody,
			    tuple_t signature, tuple_t values, bool_t no_frame)
{
  // call the function
  any_t res = 0;
  if (ptype(fnbody) == BUILTIN_T) {
    // (1) function with C code
    builtin_t f = UNWRAP_BUILTIN(fnbody);
    if(no_frame)
      res = f(values);
    else {
      begin_frame(FUNCTION_FRAME)
	res = f(values);
      end_frame(res);
    }
  }
  else {
    // (2) function with rhabarber code
    assign(local, parent_sym, scope);  // the defining scope (lexical)
    
    // assign the arguments
    int nsig = tuple_len(signature);
    for(int i = 0; i < nsig; i++) {
      any_t pattern = tuple_get(signature, i);
      if (!pattern)
	rha_error("(eval) signature is not valid");
      any_t s_o = lookup(pattern, symbol_new("patternliteral"));
      if (!s_o)
	rha_error("(eval) patternliteral expected", s_o);
      if (ptype(s_o) == SYMBOL_T) {
	symbol_t s = UNWRAP_SYMBOL(s_o);
	//debug("assigning argument number %d to '%s'\n", i, symbol_name(s));
	assign(local, s, tuple_get(values, i));
      }
    }
    if(no_frame)
      res = eval(local, fnbody);
    else {
      begin_frame(FUNCTION_FRAME)
	res = eval(local, fnbody);
      end_frame(res);
    }
  }
  return res;
}

//----------------------------------------------------------------------
//
// functions for calling a slot
//

// note on "variable argument lists" in rhabarber:
// to pull in a function like 'callslot' with '...' automatically, we
// need to implement a function 'vcallclot' with the '...' replaced by
// a 'list_t' argument.
// NOTE: we assume that the last required argument is an integer that
// tells the C function (e.g. 'callslot') how long the list really
// is.  The 'v' version of the function doesn't have it.
any_t vcallslot(any_t obj, symbol_t slotname, tuple_t args)
{
  // note that 'callslot' assumes that all arguments are already
  // evaluated in the outer calling scope.  this is important since we
  // have no longer access to the outer calling scope.  the inner
  // calling scope ('this') will be set to 'obj'
  //debug("callslot(%o, %o, %o)\n", obj, WRAP_SYMBOL(slotname), WRAP_PTR(TUPLE_T, args));
  any_t slot = lookup(obj, slotname);
  if (!slot)
    throw(excp_newf("(call_slot) object %o doesn't have slot '%s'",
		    obj, symbol_name(slotname)));
  
  // construct the call
  list_t args_l = tuple_to_list(args);
  list_prepend(args_l, slot);

  // call the slot with the scope being the object
  return call_fun(obj, list_to_tuple(args_l));
}


// note that:
// * calling 'callslot' in C calls 'callslot'
// * calling 'callslot' in Rhaberber calls 'vcallslot'
any_t callslot(any_t obj, symbol_t slotname, int_t narg, ...)
{
  //debug("callslot(%o, %o, %d, ...)\n", obj, WRAP_SYMBOL(slotname), narg);
  va_list ap;
  va_start(ap, narg);
  tuple_t args = tuple_new(narg);
  for (int i = 0; i < narg; i++)
    tuple_set(args, i, va_arg(ap, any_t));
  va_end(ap);
  
  return vcallslot(obj, slotname, args);
}
