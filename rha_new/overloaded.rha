// overloaded functions

// == and != are special
// the problem with overloading here is that type checking might use
// certain function which are overloaded themselves, which needs to be
// resolved with type checking and so on...
equalequal_fn = modules.object.equalequal_fn;
notequal_fn   = modules.object.notequal_fn;

// temporarily for testing purposes
inc             = modules.object.inc;
dec             = modules.object.dec;
inc_copy        = modules.object.inc_copy;
dec_copy        = modules.object.dec_copy;
to_string       = modules.object.to_string;


// bools
not_fn(bool:x)         = modules.bool_fn.bool_not(x);
and_fn(bool:x, bool:y) = modules.bool_fn.bool_and(x, y);
or_fn(bool:x, bool:y)  = modules.bool_fn.bool_or(x, y);
//equalequal_fn(bool:x, bool:y) = modules.bool_fn.bool_equalequal(x, y);


// strings
plus_fn(string:x, string:y) = modules.string_fn.string_concat(x, y);
string.proto.len = fn () modules.string_fn.string_len(this);
//equalequal_fn(string:x, string:y) = modules.string_fn.string_equalequal(x, y);


// types
less_fn(type:x, type:y) = x:y;
plus_fn(type:t1, type:t2) = {
  // (t1+t2):x  == t1:x && t2:x
  t = neww(type);
  t.check = fn (x) t1:x && t2:x;
  return t;
}
times_fn(type:t1, type:t2) = { 
  // int*real*string   (tuples of types)
  t = neww(type); 
  t.check = fn (x) tuple.check(x) 
                   && x.len() == 2 
                   && t1:x(0) && t2:x(1); 
  return t;
}


// integers
plus_fn(int:x, int:y) = modules.int_fn.int_plus(x, y);
neg_fn(int:x) = modules.int_fn.int_neg(x);
minus_fn(int:x, int:y) = modules.int_fn.int_minus(x, y);
times_fn(int:x, int:y) = modules.int_fn.int_times(x, y);
divide_fn(int:x, int:y) = modules.int_fn.int_divide(x, y);
less_fn(int:x, int:y) = modules.int_fn.int_less(x, y);
lessequal_fn(int:x, int:y) = modules.int_fn.int_lessequal(x, y);
greater_fn(int:x, int:y) = modules.int_fn.int_greater(x, y);
greaterequal_fn(int:x, int:y) = modules.int_fn.int_greaterequal(x, y);
int(real:x) = modules.int_fn.int_cast(x);  // try 'int(3.14)'
//equalequal_fn(int:x, int:y) = modules.int_fn.int_equalequal(x, y);


// tuples
tuple.proto.len = fn () modules.tuple_fn.tuple_len(this);
tuple.proto.set = fn (i, x) modules.tuple_fn.tuple_set(this, i, x);
tuple.proto.get = fn (i) modules.tuple_fn.tuple_get(this, i);
// a simple constructor for tuples is defined by:
tuple.new = modules.tuple_fn.tuple_new;
// this allows stuff like: t = tuple.new(4);
// however, let's try to be fancy and make 'tuple' a function itself:
tuple(len) = modules.tuple_fn.tuple_new(len);
tuple.proto.iter = fn () {
  i = new();
  i.counter = 0;
  i.tuple = this;
  i.done = fn () i.counter == i.tuple.len();
  i.next = fn () this.counter++;
  i.get = fn () this.tuple.get(this.counter);
  return i;
}
tuple.proto(i) = static.get(i); // member access, e.g. t(0)


// lists
list.new = modules.list_fn.list_new;
list() = modules.list_fn.list_new();
list.proto.len      = fn () modules.list_fn.list_len(this);
list.proto.copy     = fn () modules.list_fn.list_copy(this);
list.proto.append   = fn (x) modules.list_fn.list_append(this, x);
list.proto.prepend  = fn (x) modules.list_fn.list_prepend(this, x);
list.proto.extend   = fn (l) modules.list_fn.list_extend(this, l);
list.proto.first    = fn () modules.list_fn.list_first(this);
list.proto.last     = fn () modules.list_fn.list_last(this);
list.proto.pop      = fn () modules.list_fn.list_poplast(this);
list.proto.push     = fn () modules.list_fn.list_append(this);
list.proto.shift    = fn () modules.list_fn.list_popfirst(this);
list.proto.unshift  = fn () modules.list_fn.list_prepend(this);
list.proto.to_tuple = fn () modules.list_fn.list_to_tuple(this);
list.proto.iter     = fn () {
  i = modules.list_fn.list_begin(this);
  i.next = fn () modules.list_fn.list_next(this);
  i.done = fn () modules.list_fn.list_done(this);
  i.get  = fn () modules.list_fn.list_get(this);
  return i;
}



